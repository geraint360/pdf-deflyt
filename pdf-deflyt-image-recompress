#!/usr/bin/env python3
"""
pdf-deflyt-image-recompress
Helper script for pdf-deflyt to handle ICC profile images using ImageMagick

DEPENDENCIES:
  System: ImageMagick (brew install imagemagick)
  Python: PyMuPDF (auto-installed in local venv on first run)

The script automatically creates a local virtual environment (.pdf-deflyt-venv)
and installs PyMuPDF on first run. No manual pip installation required.

USAGE:
  pdf-deflyt-image-recompress [-v] [-q QUALITY] INPUT OUTPUT
  
This script is normally called by pdf-deflyt automatically when needed.
"""

import sys
import os
import subprocess
import tempfile
import shutil
from pathlib import Path

def check_imagemagick():
    """Check if ImageMagick is available (magick or convert)"""
    return shutil.which('magick') is not None or shutil.which('convert') is not None

# Virtual environment setup for PyMuPDF only
SCRIPT_DIR = Path(__file__).parent.resolve()
VENV_DIR = SCRIPT_DIR / ".pdf-deflyt-venv"
VENV_PYTHON = VENV_DIR / "bin" / "python3"

def setup_venv():
    """Create virtual environment and install PyMuPDF only"""
    if VENV_DIR.exists():
        return True
    
    print("First run: Setting up Python environment...", file=sys.stderr)
    try:
        subprocess.run([sys.executable, "-m", "venv", str(VENV_DIR)], check=True)
        print("Installing PyMuPDF...", file=sys.stderr)
        subprocess.run([
            str(VENV_PYTHON), "-m", "pip", "install", "--quiet", "PyMuPDF"
        ], check=True)
        print("Setup complete!", file=sys.stderr)
        return True
    except subprocess.CalledProcessError as e:
        print(f"ERROR: Failed to setup environment: {e}", file=sys.stderr)
        return False

def run_in_venv():
    """Re-run this script in the virtual environment"""
    if not VENV_PYTHON.exists():
        if not setup_venv():
            sys.exit(1)
    os.execv(str(VENV_PYTHON), [str(VENV_PYTHON), __file__] + sys.argv[1:])

# If not running in venv, switch to it
if sys.prefix == sys.base_prefix:
    run_in_venv()

# Now in venv, import PyMuPDF
import fitz
import argparse

# Configuration constants
IMAGEMAGICK_TIMEOUT = 30  # seconds for ImageMagick conversion operations
PYMUPDF_GARBAGE_LEVEL = 4  # Level 4: aggressive garbage collection

def convert_image_with_imagemagick(input_bytes, quality=75, resize_percent=0):
    """Convert image to JPEG using ImageMagick (preserves ICC)

    Args:
        input_bytes: Image data bytes
        quality: JPEG quality (1-100)
        resize_percent: Resize percentage for downsampling (0=no resize, e.g., 70=resize to 70%)
    """
    with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as tmp_in:
        tmp_in.write(input_bytes)
        tmp_in_path = tmp_in.name

    tmp_out_path = tmp_in_path.replace('.png', '.jpg')

    try:
        # Build resize argument if resize_percent is specified
        resize_args = []
        if resize_percent > 0 and resize_percent < 100:
            resize_args = ['-resize', f'{resize_percent}%']

        # Try different ImageMagick command variants
        commands = [
            ['magick', tmp_in_path] + resize_args + ['-quality', str(quality), tmp_out_path],  # IM7 Linux style
            ['magick', 'convert', tmp_in_path] + resize_args + ['-quality', str(quality), tmp_out_path],  # IM7 macOS style
            ['convert', tmp_in_path] + resize_args + ['-quality', str(quality), tmp_out_path]  # IM6 style
        ]

        for cmd in commands:
            if not shutil.which(cmd[0]):
                continue

            result = subprocess.run(cmd, capture_output=True, timeout=IMAGEMAGICK_TIMEOUT)

            if result.returncode == 0 and os.path.exists(tmp_out_path):
                with open(tmp_out_path, 'rb') as f:
                    jpeg_bytes = f.read()
                return jpeg_bytes

        return None

    finally:
        # Clean up temp files - failures are non-fatal, OS will clean up /tmp
        try:
            os.unlink(tmp_in_path)
            if os.path.exists(tmp_out_path):
                os.unlink(tmp_out_path)
        except (OSError, IOError):
            pass

def recompress_pdf_images(input_path, output_path, quality=75, verbose=False, color_dpi=0, gray_dpi=0):
    """Recompress images using ImageMagick for ICC safety

    Args:
        input_path: Input PDF path
        output_path: Output PDF path
        quality: JPEG quality (1-100)
        verbose: Enable verbose output
        color_dpi: Target DPI for color images (0=no downsampling)
        gray_dpi: Target DPI for grayscale images (0=no downsampling)
    """

    if not check_imagemagick():
        print("ERROR: ImageMagick not found. Install with: brew install imagemagick", file=sys.stderr)
        return 1

    try:
        doc = fitz.open(input_path)

        if verbose:
            print(f"Processing {len(doc)} pages...", file=sys.stderr)

        for page_num in range(len(doc)):
            page = doc[page_num]
            image_list = page.get_images(full=True)

            if verbose and image_list:
                print(f"  Page {page_num + 1}: {len(image_list)} images", file=sys.stderr)

            for img_index, img in enumerate(image_list):
                xref = img[0]
                smask_xref = img[1] if len(img) > 1 else 0  # Soft mask reference

                try:
                    # Skip images with soft masks (transparency) - PyMuPDF's insert_image()
                    # doesn't properly preserve transparency when re-inserting
                    if smask_xref > 0:
                        if verbose:
                            print(f"    Image {img_index + 1}: Skipping (has transparency/smask)", file=sys.stderr)
                        continue

                    # Get image placement to calculate actual DPI
                    img_rects = page.get_image_rects(xref)
                    if not img_rects:
                        if verbose:
                            print(f"    Image {img_index + 1}: WARNING - Could not find image position, skipping", file=sys.stderr)
                        continue

                    # Extract image
                    base_image = doc.extract_image(xref)
                    image_bytes = base_image["image"]
                    image_ext = base_image["ext"]
                    width = base_image["width"]
                    height = base_image["height"]
                    colorspace = base_image.get("colorspace", 3)  # Default to 3 (RGB/color)

                    # Calculate actual DPI from image dimensions and page placement
                    # Page coordinates are in points (72 points = 1 inch)
                    rect = img_rects[0]  # Use first placement
                    rendered_width_inches = rect.width / 72.0
                    rendered_height_inches = rect.height / 72.0
                    actual_dpi_x = width / rendered_width_inches if rendered_width_inches > 0 else 0
                    actual_dpi_y = height / rendered_height_inches if rendered_height_inches > 0 else 0
                    actual_dpi = (actual_dpi_x + actual_dpi_y) / 2  # Average

                    # Determine target DPI based on colorspace
                    # colorspace: 1=gray, 3=RGB, 4=CMYK
                    target_dpi = 0
                    if colorspace == 1 and gray_dpi > 0:
                        target_dpi = gray_dpi
                    elif colorspace in (3, 4) and color_dpi > 0:
                        target_dpi = color_dpi

                    # Calculate resize percentage (0 = no resize)
                    resize_percent = 0
                    if target_dpi > 0 and actual_dpi > target_dpi:
                        resize_percent = int((target_dpi / actual_dpi) * 100)

                    if verbose:
                        cs_name = "gray" if colorspace == 1 else "color"
                        dpi_info = f", {int(actual_dpi)} → {target_dpi} DPI ({resize_percent}%)" if resize_percent > 0 else f", {int(actual_dpi)} DPI"
                        if image_ext in ("jpeg", "jpg"):
                            print(f"    Image {img_index + 1} ({cs_name}): recompressing JPEG (Q{quality}{dpi_info})", file=sys.stderr)
                        else:
                            print(f"    Image {img_index + 1} ({cs_name}): converting {image_ext} to JPEG (Q{quality}{dpi_info})", file=sys.stderr)

                    # Convert using ImageMagick
                    new_image_bytes = convert_image_with_imagemagick(image_bytes, quality, resize_percent)
                    
                    if new_image_bytes is None:
                        if verbose:
                            print(f"      WARNING: ImageMagick conversion failed, skipping", file=sys.stderr)
                        continue
                    
                    # Only update if smaller
                    if len(new_image_bytes) >= len(image_bytes):
                        if verbose:
                            print(f"      Kept original (would be larger)", file=sys.stderr)
                        continue

                    # Delete the old image (we already have img_rects from earlier)
                    page.delete_image(xref)
                    
                    # Insert the new JPEG at each location where the old image was
                    for rect in img_rects:
                        page.insert_image(rect, stream=new_image_bytes, keep_proportion=True)
                    
                    if verbose:
                        reduction = (1 - len(new_image_bytes)/len(image_bytes)) * 100
                        print(f"      Compressed: {len(image_bytes)} → {len(new_image_bytes)} bytes ({reduction:.1f}% smaller)", file=sys.stderr)
                    
                except Exception as e:
                    if verbose:
                        print(f"    WARNING: Failed to process image {img_index + 1}: {e}", file=sys.stderr)
                    continue

        # Save
        doc.save(output_path, garbage=PYMUPDF_GARBAGE_LEVEL, deflate=True, clean=True)
        doc.close()
        
        if verbose:
            print(f"Saved to: {output_path}", file=sys.stderr)
        
        return 0
        
    except Exception as e:
        print(f"ERROR: Failed to process PDF: {e}", file=sys.stderr)
        return 1

def main():
    parser = argparse.ArgumentParser(description='Recompress PDF images using ImageMagick')
    parser.add_argument('input', help='Input PDF file')
    parser.add_argument('output', help='Output PDF file')
    parser.add_argument('-q', '--quality', type=int, default=75, help='JPEG quality (1-100, default: 75)')
    parser.add_argument('--color-dpi', type=int, default=0, help='Target DPI for color images (0=no downsampling)')
    parser.add_argument('--gray-dpi', type=int, default=0, help='Target DPI for grayscale images (0=no downsampling)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')

    args = parser.parse_args()

    if not Path(args.input).exists():
        print(f"ERROR: Input file not found: {args.input}", file=sys.stderr)
        return 1

    return recompress_pdf_images(args.input, args.output, args.quality, args.verbose, args.color_dpi, args.gray_dpi)

if __name__ == '__main__':
    sys.exit(main())