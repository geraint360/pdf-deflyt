#!/bin/zsh
set -e
set -o pipefail

# pdf-deflyt v2.3.0-zsh
# - Auto-tuned compression via image PPI analysis
# - Presets: light, standard, extreme, lossless, archive
# - Batch + recurse + parallel processing
# - Special handling for ICC profile images via ImageMagick
# - Metadata & timestamps preserved by default
#
# Dependencies (Homebrew):
#   brew install ghostscript pdfcpu qpdf mupdf exiftool poppler coreutils imagemagick
#   brew install parallel  # optional, for parallel processing
#
# For ICC profile image support:
#   - ImageMagick is required (brew install imagemagick)
#   - Helper script pdf-deflyt-image-recompress must be in same directory
#   - Python dependencies are auto-managed by the helper (no manual setup)

usage() {
  cat <<'EOF'
Usage:
  pdf-deflyt [OPTIONS] INPUT...

Examples:
  pdf-deflyt document.pdf              # Creates document_deflyt.pdf
  pdf-deflyt --inplace *.pdf           # Compress in place (auto-backup)
  pdf-deflyt --recurse ~/Documents     # Batch process folder
  pdf-deflyt --dry-run *.pdf           # Preview savings

Presets:
  -p standard   (default) Auto-tuned per-PDF based on content analysis
  -p light      Higher quality, larger files (300dpi, Q78)
  -p extreme    Maximum compression, smaller files (144dpi, Q68)
  -p lossless   Structure-only, no image recompression (ultra-safe)

Common Options:
  --inplace            Replace originals (creates automatic .bak backup)
  --recurse            Process PDFs in subdirectories
  -o FILE              Output path (single input only)
  --dry-run            Analyze and show estimated savings without processing

Control:
  --min-gain PCT       Skip files with < PCT savings (default: 1)
  --skip-small SIZE    Skip files smaller than SIZE (e.g., 500K, 1MB)
  --jobs N             Parallel workers (default: auto-detect cores)
  --backup             Create .bak files with --inplace (default: enabled)

Output:
  --quiet              Minimal output
  --verbose            Detailed output
  --help, -h           Show this help
  --help-advanced      Show advanced options
  --version            Show version

For advanced options (filtering, security, hooks, logging):
  pdf-deflyt --help-advanced
EOF
  exit 2
}

advanced_usage() {
  cat <<'EOF'
Advanced Options for pdf-deflyt

Security:
  --password TEXT          Decrypt password
  --password-file FILE     Read password from file

Filtering (regex on full path):
  --exclude REGEX          Exclude files matching pattern (repeatable)
  --include REGEX          Include only files matching pattern (repeatable)

Validation & Recovery:
  --validate               Validate PDFs after compression
  --resume STATE           Resume interrupted batch job
  --check-deps             Verify all dependencies are installed

Automation & Logging:
  --log CSV                Write processing log to CSV file
  --sidecar-sha256         Create SHA256 sidecar files
  --post-hook 'CMD {}'     Run command after each file
                           Available env vars: IN, OUT, ORIG_BYTES, OUT_BYTES, PRESET, SAVEPCT

Resource Control:
  --memory-limit SIZE      Max memory for Ghostscript (e.g., 512M, 2G)

Output Control:
  --debug                  Debug output (implies --verbose)
  --color auto|always|never Control colored output (default: auto)

Notes:
  - pdf-deflyt always preserves metadata and timestamps
  - pdf-deflyt always produces deterministic output
  - For most users, the basic options are sufficient
EOF
  exit 2
}

# ============================================================================
# Configuration Constants (immutable)
# ============================================================================
readonly VERSION="2.3.0-zsh"
readonly IMAGEMAGICK_TIMEOUT=30  # seconds for ImageMagick operations
readonly PYMUPDF_GARBAGE_LEVEL=4  # PyMuPDF garbage collection level
readonly APFS_TIME_TOLERANCE=120   # seconds tolerance for timestamp preservation

# Dependency lists
readonly -a REQUIRED_DEPS=(gs pdfcpu qpdf mutool exiftool pdfinfo pdfimages sha256sum gstat)
readonly -a REQUIRED_PKGS=('ghostscript' 'pdfcpu' 'qpdf' 'mupdf' 'exiftool' 'poppler' 'poppler' 'coreutils' 'coreutils')
readonly -a OPTIONAL_DEPS=(parallel magick)
readonly -a OPTIONAL_PKGS=('parallel' 'imagemagick')

# Helper script path (can be overridden via environment: export PDF_DEFLYT_HELPER=/path/to/helper)
: "${PDF_DEFLYT_HELPER:=}"

# Caching directory for performance optimizations
readonly CACHE_DIR="${TMPDIR:-/tmp}/pdf-deflyt-cache-${USER:-$(id -u)}"
readonly DEPS_CACHE="$CACHE_DIR/deps.cache"
readonly CACHE_TTL=86400  # 24 hours in seconds

# ============================================================================
# Runtime Configuration (set by command-line arguments)
# ============================================================================

# File lists and filters
typeset -a ARGS FILES EXCLUDES INCLUDES

# Compression settings
PRESET="standard"

# Output options
OUT_SINGLE=""
INPLACE=false
BACKUP=false
VALIDATE=false
RESUME_STATE=""

# Processing mode
RECURSE=false
JOBS=1
DRYRUN=false
DEBUG=false
CHECK_DEPS=false

# Logging
LOGFILE=""
QUIET=${QUIET:-false}
VERBOSE=0  # 0=normal, 1=verbose, 2=debug (backward compat: DEBUG=true sets to 2)
USE_COLOR=auto  # auto, always, never

# File filtering
MIN_GAIN=1
SKIP_UNDER_BYTES=""

# Resource management
MEMORY_LIMIT=""

# Metadata and timestamps (always enabled for consistency)
readonly KEEP_METADATA=true
readonly KEEP_DATE=true
readonly DETERMINISTIC=true

# Security
PASSWORD=""
PASSWORD_FILE=""

# Hooks and sidecars
POST_HOOK=""
SIDECAR=false

# Internal flags
INTERNAL_ONE=false

# Batch statistics
typeset -i STATS_TOTAL=0 STATS_PROCESSED=0 STATS_SKIPPED=0 STATS_FAILED=0
typeset -i STATS_BYTES_IN=0 STATS_BYTES_OUT=0
STATS_START_TIME=0

log() { $QUIET || printf '%s\n' "$@"; }

while [[ $# -gt 0 ]]; do
  case "$1" in
    -p) PRESET="${2:-}"; shift 2 ;;
    -o) OUT_SINGLE="${2:-}"; shift 2 ;;
    --recurse) RECURSE=true; shift ;;
    --jobs) JOBS="${2:-1}"; shift 2 ;;
    --inplace) INPLACE=true; shift ;;
    --backup) BACKUP=true; shift ;;
    --validate) VALIDATE=true; shift ;;
    --resume) RESUME_STATE="${2:-}"; shift 2 ;;
    --dry-run) DRYRUN=true; shift ;;
    --debug) DEBUG=true; VERBOSE=2; shift ;;
    --verbose) VERBOSE=1; shift ;;
    --color) USE_COLOR="${2:-auto}"; shift 2 ;;
    --log) LOGFILE="${2:-}"; shift 2 ;;
    --min-gain) MIN_GAIN="${2:-1}"; shift 2 ;;
    --skip-if-smaller) SKIP_UNDER_BYTES="${2:-}"; shift 2 ;;
    --memory-limit) MEMORY_LIMIT="${2:-}"; shift 2 ;;
    --password) PASSWORD="${2:-}"; shift 2 ;;
    --password-file) PASSWORD_FILE="${2:-}"; shift 2 ;;
    --post-hook) POST_HOOK="${2:-}"; shift 2 ;;
    --sidecar-sha256) SIDECAR=true; shift ;;
    --quiet) QUIET=true; shift ;;
    --exclude) EXCLUDES+=("${2:-}"); shift 2 ;;
    --include) INCLUDES+=("${2:-}"); shift 2 ;;
    --internal-one) INTERNAL_ONE=true; shift ;;
    --check-deps) CHECK_DEPS=true; shift ;;
    --help|-h) usage ;;
    --help-advanced) advanced_usage ;;
    --version) echo "$VERSION"; exit 0 ;;
    --) shift; break ;;
    -*) echo "Unknown option: $1" >&2; usage ;;
    *) ARGS+=("$1"); shift ;;
  esac
done

[[ ${#ARGS[@]} -ge 1 || $INTERNAL_ONE = true || $CHECK_DEPS = true || -n "$RESUME_STATE" ]] || usage
if [[ -n "$OUT_SINGLE" && ${#ARGS[@]} -ne 1 && $INTERNAL_ONE = false ]]; then
  echo "ERROR: -o option requires exactly one input file (got ${#ARGS[@]})" >&2
  exit 2
fi

# Validate color option
case "$USE_COLOR" in
  auto|always|never) ;;
  *) echo "ERROR: --color must be 'auto', 'always', or 'never' (got: $USE_COLOR)" >&2; exit 2 ;;
esac

# Detect TTY and set up colors
ENABLE_COLOR=false
if [[ "$USE_COLOR" == "always" ]] || { [[ "$USE_COLOR" == "auto" ]] && [[ -t 1 ]]; }; then
  ENABLE_COLOR=true
fi

# Color codes (using tput for portability)
if $ENABLE_COLOR && command -v tput >/dev/null 2>&1; then
  C_RED=$(tput setaf 1 2>/dev/null || echo '')
  C_GREEN=$(tput setaf 2 2>/dev/null || echo '')
  C_YELLOW=$(tput setaf 3 2>/dev/null || echo '')
  C_BLUE=$(tput setaf 4 2>/dev/null || echo '')
  C_MAGENTA=$(tput setaf 5 2>/dev/null || echo '')
  C_CYAN=$(tput setaf 6 2>/dev/null || echo '')
  C_BOLD=$(tput bold 2>/dev/null || echo '')
  C_RESET=$(tput sgr0 2>/dev/null || echo '')
else
  C_RED= C_GREEN= C_YELLOW= C_BLUE= C_MAGENTA= C_CYAN= C_BOLD= C_RESET=
fi

# Enhanced logging functions
log_error() { echo "${C_RED}ERROR:${C_RESET} $*" >&2; }
log_warn() { echo "${C_YELLOW}WARNING:${C_RESET} $*" >&2; }
log_info() { $QUIET || echo "${C_BLUE}INFO:${C_RESET} $*"; }
log_success() { $QUIET || echo "${C_GREEN}✓${C_RESET} $*"; }
log_verbose() { (( VERBOSE >= 1 )) && echo "${C_CYAN}VERBOSE:${C_RESET} $*"; }
log_debug() { (( VERBOSE >= 2 )) && echo "${C_MAGENTA}DEBUG:${C_RESET} $*"; }

# Validate password file
if [[ -n "$PASSWORD_FILE" ]]; then
  if [[ ! -f "$PASSWORD_FILE" ]]; then
    log_error "Password file not found: $PASSWORD_FILE"
    log_info "Suggestion: Check the file path or create the password file with the PDF password on the first line"
    exit 2
  fi
  if [[ ! -r "$PASSWORD_FILE" ]]; then
    log_error "Cannot read password file: $PASSWORD_FILE"
    log_info "Suggestion: Check file permissions (should be readable): chmod 600 $PASSWORD_FILE"
    exit 2
  fi
  PASSWORD="$(/usr/bin/head -n1 "$PASSWORD_FILE" 2>/dev/null || true)"
  if [[ -z "$PASSWORD" ]]; then
    log_error "Password file is empty: $PASSWORD_FILE"
    log_info "Suggestion: Add the PDF password as the first line in the file"
    exit 2
  fi
fi

# Validate JPEG quality
if [[ -n "$JPEGQ_OVERRIDE" ]]; then
  if ! [[ "$JPEGQ_OVERRIDE" =~ ^[0-9]+$ ]] || (( JPEGQ_OVERRIDE < 1 || JPEGQ_OVERRIDE > 100 )); then
    log_error "JPEG quality must be between 1 and 100 (got: $JPEGQ_OVERRIDE)"
    log_info "Suggestion: Use -q with a value between 1 (lowest quality) and 100 (highest quality)"
    log_info "           Recommended: 68 (extreme), 74 (standard), 78 (light)"
    exit 2
  fi
fi

# Validate jobs parameter
if ! [[ "$JOBS" =~ ^[0-9]+$ ]] || (( JOBS < 1 )); then
  log_error "--jobs must be a positive integer (got: $JOBS)"
  log_info "Suggestion: Use --jobs 4 for 4 parallel workers (requires GNU parallel or xargs -P)"
  exit 2
fi

# Validate and parse memory limit
MEMORY_LIMIT_BYTES=""
if [[ -n "$MEMORY_LIMIT" ]]; then
  MEMORY_LIMIT_BYTES="$(parse_bytes "$MEMORY_LIMIT")"
  if [[ -z "$MEMORY_LIMIT_BYTES" ]]; then
    log_error "Invalid memory limit format: $MEMORY_LIMIT"
    log_info "Suggestion: Use format like --memory-limit 512M or --memory-limit 2G"
    exit 2
  fi
fi

# Validate backup option
if $BACKUP && ! $INPLACE; then
  log_warn "--backup has no effect without --inplace"
  log_info "Suggestion: Use --inplace --backup to create .bak files before replacing originals"
fi

check_deps() {
  local -a REQ_CMDS REQ_DESC OPT_CMDS OPT_DESC
  REQ_CMDS=("${REQUIRED_DEPS[@]}")
  REQ_DESC=("${REQUIRED_PKGS[@]}")
  OPT_CMDS=("${OPTIONAL_DEPS[@]}")
  OPT_DESC=("${OPTIONAL_PKGS[@]}")

  local missing=0

  printf "%-12s  %-10s  %s\n" "COMMAND" "STATUS" "HOMEBREW PACKAGE"
  printf "%-12s  %-10s  %s\n" "--------" "------" "------------------"

  local i=1
  for cmd in "${REQ_CMDS[@]}"; do
    local pkg="${REQ_DESC[$i]}"; ((i++))
    if command -v "$cmd" >/dev/null 2>&1; then
      printf "%-12s  %-10s  %s\n" "$cmd" "OK" "$pkg"
    else
      printf "%-12s  %-10s  %s\n" "$cmd" "MISSING" "$pkg"
      missing=1
    fi
  done

  local j=1
  while (( j <= ${#OPT_CMDS[@]} )); do
    local ocmd="${OPT_CMDS[$j]}"
    local opkg="${OPT_DESC[$j]}"
    if command -v "$ocmd" >/dev/null 2>&1; then
      printf "%-12s  %-10s  %s (optional)\n" "$ocmd" "OK" "$opkg"
    else
      printf "%-12s  %-10s  %s (optional)\n" "$ocmd" "MISSING" "$opkg"
    fi
    ((j++))
  done

  echo
  echo "Install with:"
  echo "  brew install ghostscript pdfcpu qpdf mupdf exiftool poppler coreutils imagemagick parallel"

  return $missing
}

# Cross-platform stat helpers
size_of() {
  { command gstat -c%s "$1" 2>/dev/null || \
    stat -f%z "$1" 2>/dev/null || \
    stat -c%s "$1" 2>/dev/null; }
}

stat_time() {
  local file="$1" type="$2"  # type: atime or mtime
  case "$type" in
    atime) { command gstat -c %X "$file" 2>/dev/null || \
             stat -f %a "$file" 2>/dev/null || \
             stat -c %X "$file" 2>/dev/null; } ;;
    mtime) { command gstat -c %Y "$file" 2>/dev/null || \
             stat -f %m "$file" 2>/dev/null || \
             stat -c %Y "$file" 2>/dev/null; } ;;
    *) echo "0" ;;
  esac
}

parse_bytes() {
  local s="${1:-}"; [[ -z "$s" ]] && { echo ""; return; }
  s="${s//[[:space:]]/}"; s="${s:u}"
  [[ "$s" =~ '^[0-9]+$' ]] && { echo "$s"; return; }
  if print -r -- "$s" | command grep -E -q '^[0-9]+(\.[0-9]+)?(K|KB|M|MB|G|GB)$'; then
    local n="${s%[KkMmGg][Bb]}" u="${s##*[0-9]}"
    case "$u" in
      K|KB) awk -v n="$n" 'BEGIN{printf "%.0f", n*1024}' ;;
      M|MB) awk -v n="$n" 'BEGIN{printf "%.0f", n*1024*1024}' ;;
      G|GB) awk -v n="$n" 'BEGIN{printf "%.0f", n*1024*1024*1024}' ;;
    esac; return
  fi
  echo "ERROR: Invalid SIZE format: '$1'. Expected format: 200K, 1.5MB, 2GB" >&2; exit 2
}

fmt_bytes() {
  local b="$1"
  awk -v b="$b" 'BEGIN{
    if (b<1024){printf "%d B", b; exit}
    kb=b/1024; if (kb<1024){printf "%.1f KB", kb; exit}
    mb=kb/1024; if (mb<1024){printf "%.2f MB", mb; exit}
    gb=mb/1024; printf "%.2f GB", gb
  }'
}

# Initialize cache directory
init_cache() {
  mkdir -p "$CACHE_DIR" 2>/dev/null || true
  chmod 700 "$CACHE_DIR" 2>/dev/null || true
}

# Check if cache file is fresh (within TTL)
is_cache_fresh() {
  local cache_file="$1"
  [[ -f "$cache_file" ]] || return 1

  local cache_mtime=$(stat_time "$cache_file" mtime)
  local now=$(date +%s)
  local age=$((now - cache_mtime))

  [[ $age -lt $CACHE_TTL ]]
}

need() {
  command -v "$1" >/dev/null 2>&1 || {
    echo "ERROR: Missing required dependency: $1" >&2
    echo "Install with: brew install ghostscript pdfcpu qpdf mupdf exiftool poppler coreutils" >&2
    exit 127
  }
}
if $CHECK_DEPS; then check_deps; exit $?; fi

# Check dependencies with caching
init_cache

# Initialize PARALLEL_OK to false (will be set to true if parallel is available)
PARALLEL_OK=false

# Try to load cached dependency check results
if is_cache_fresh "$DEPS_CACHE"; then
  # Cache is fresh, load it
  source "$DEPS_CACHE" 2>/dev/null || {
    # Cache corrupted, regenerate
    rm -f "$DEPS_CACHE" 2>/dev/null || true
  }
fi

# If not cached or cache was corrupted, run checks and cache results
if [[ ! -f "$DEPS_CACHE" ]] || ! is_cache_fresh "$DEPS_CACHE"; then
  # Run dependency checks
  for t in pdfcpu qpdf mutool exiftool pdfinfo pdfimages gs sha256sum; do need "$t"; done
  PARALLEL_OK=false; command -v parallel >/dev/null 2>&1 && PARALLEL_OK=true

  # Cache results (store as shell variables)
  {
    echo "# pdf-deflyt dependency cache - $(date)"
    echo "PARALLEL_OK=$PARALLEL_OK"
  } > "$DEPS_CACHE" 2>/dev/null || true
else
  # Using cached results, still verify critical dependencies exist
  for t in pdfcpu qpdf mutool exiftool pdfinfo pdfimages gs sha256sum; do need "$t"; done
fi

is_pdf() { [[ "${1:l}" == *.pdf ]]; }
gather_one() {
  local in="$1"
  if [[ -d "$in" ]]; then
    if $RECURSE; then
      command find "$in" -type f \( -iname '*.pdf' -o -iname '*.PDF' \)
    else
      for f in "$in"/*; do [[ -f "$f" && "${f:l}" == *.pdf ]] && print -r -- "$f"; done
    fi
  elif [[ -f "$in" ]]; then
    print -r -- "$in"
  fi
}

if $INTERNAL_ONE; then FILES=("$1")
else
  FILES=()
  for x in "${ARGS[@]}"; do
    while IFS= read -r line; do
      FILES+=("$line")
    done < <(gather_one "$x")
  done
fi
[[ ${#FILES[@]} -ge 1 ]] || { echo "ERROR: No PDF files found in the specified location(s)" >&2; exit 1; }

if $DEBUG; then
  printf 'DEBUG: FILES(%d):\n' "${#FILES[@]}"
  for p in "${FILES[@]}"; do printf '  %s\n' "$p"; done
fi

filter_files() {
  local -a input; input=("$@"); local -a keep
  for f in "${input[@]}"; do
    [[ "${f:l}" == *.pdf ]] || continue
    local skip=false
    for pat in "${EXCLUDES[@]}"; do print -r -- "$f" | command grep -E -q -- "$pat" && { skip=true; break; }; done
    $skip && continue
    if (( ${#INCLUDES[@]} > 0 )); then
      local matched=false
      for pat in "${INCLUDES[@]}"; do print -r -- "$f" | command grep -E -q -- "$pat" && { matched=true; break; }; done
      $matched || continue
    fi
    keep+=("$f")
  done
  print -r -- "${keep[@]}" 2>/dev/null || true
}
if ! $INTERNAL_ONE; then
  FILES=("${(f)$(filter_files "${FILES[@]}")}")
  [[ ${#FILES[@]} -ge 1 ]] || { echo "ERROR: No PDF files remaining after applying filters" >&2; exit 1; }
fi

restore_times() { touch -r "$1" "$2" 2>/dev/null || true; }

unique_filename() {
  local base="$1"
  local ext="${base##*.}"
  local name="${base%.*}"
  local candidate="$base"
  local counter=2
  while [[ -e "$candidate" ]]; do
    candidate="${name} (${counter}).${ext}"
    ((counter++))
  done
  echo "$candidate"
}

analyse_pdf() {
  local f="$1"

  # Generate cache key based on file path and modification time
  local file_mtime=$(stat_time "$f" mtime)
  local cache_key=$(echo -n "${f}:${file_mtime}" | sha256sum | awk '{print $1}')
  local analysis_cache="$CACHE_DIR/analysis_${cache_key}.cache"

  # Check if we have a fresh cached analysis
  if [[ -f "$analysis_cache" ]] && is_cache_fresh "$analysis_cache"; then
    # Verify the cached mtime matches current file mtime
    local cached_mtime=$(head -n1 "$analysis_cache" 2>/dev/null | cut -d: -f2)
    if [[ "$cached_mtime" == "$file_mtime" ]]; then
      # Cache is valid, return cached result
      tail -n1 "$analysis_cache" 2>/dev/null || echo "0 0 0 0 0 0 0 0 0"
      return
    fi
  fi

  # No cache or cache invalid, run analysis
  local list
  if ! list="$(pdfimages -list "$f" 2>/dev/null)"; then
    echo "0 0 0 0 0 0 0 0 0"; return
  fi

  local parsed
  parsed=$(print -r -- "$list" | awk '
    function isgray(s,    t){ t=tolower(s); return (t=="gray" || t=="greyscale" || t=="grey") }
    function med(a, n,    i,j,tmp){
      if (n==0) return 0
      for (i=1;i<=n;i++) for (j=i+1;j<=n;j++) if (a[j] < a[i]) { tmp=a[i]; a[i]=a[j]; a[j]=tmp }
      return (n%2)? a[(n+1)/2] : (a[n/2]+a[n/2+1])/2
    }
    function minv(a, n,   i,m){
      if (n==0) return 0
      m=a[1]; for (i=2;i<=n;i++) if (a[i]<m) m=a[i]; return m
    }

    BEGIN {
      headerSeen=sepSeen=0
      xcol=ycol=colorcol=bpccol=0
      cN=gN=mN=0
    }

    /^page[[:space:]]+num[[:space:]]+type/ {
      headerSeen=1
      for (i=1; i<=NF; i++) {
        if ($i=="x-ppi") xcol=i
        else if ($i=="y-ppi") ycol=i
        else if ($i=="color") colorcol=i
        else if ($i=="bpc")   bpccol=i
      }
      next
    }

    /^-+/ { if (headerSeen) { sepSeen=1; next } }

    {
      if (!sepSeen || xcol==0 || ycol==0 || colorcol==0 || bpccol==0) next
      x=$xcol; y=$ycol; col=$colorcol; bpc=$bpccol
      if ((x+0)==0 && (y+0)==0) next

      ppi=(x+y)/2
      if (isgray(col)) {
        g[++gN]=ppi
      } else if (tolower(col)=="icc" || tolower(col)=="rgb" || tolower(col)=="cmyk") {
        c[++cN]=ppi
      } else if ((bpc+0)==1) {
        m[++mN]=ppi
      }
    }

    END {
      C_CNT=cN+0; G_CNT=gN+0; M_CNT=mN+0
      C_MED=med(c, C_CNT); G_MED=med(g, G_CNT); M_MED=med(m, M_CNT)
      C_MIN=minv(c, C_CNT); G_MIN=minv(g, G_CNT); M_MIN=minv(m, M_CNT)
      printf "%d %d %d %.0f %.0f %.0f %.0f %.0f %.0f\n",
             C_CNT, G_CNT, M_CNT, C_MED, G_MED, M_MED, C_MIN, G_MIN, M_MIN
    }')

  # Cache the analysis result for reuse
  if [[ -n "$parsed" ]]; then
    # Write cache: store mtime and parsed result
    {
      echo "mtime:${file_mtime}"
      echo "$parsed"
    } > "$analysis_cache" 2>/dev/null || true
    echo "$parsed"
  else
    echo "0 0 0 0 0 0 0 0 0"
  fi
}

sha_sidecar() {
  local which="$1" file="$2"
  if ! sha256sum "$file" > "${file}.${which}.sha256" 2>/dev/null; then
    log "WARNING: Failed to create $which SHA256 sidecar for: ${file##*/}"
    return 1
  fi
  return 0
}

validate_pdf() {
  local file="$1"
  log_verbose "Validating PDF: ${file##*/}"

  # Quick check with pdfinfo
  if ! pdfinfo "$file" >/dev/null 2>&1; then
    log_error "PDF validation failed (pdfinfo): ${file##*/}"
    log_info "Suggestion: The PDF may be corrupt. Try opening it in a PDF viewer to confirm."
    return 1
  fi

  # Thorough check with qpdf if requested
  if $VALIDATE; then
    if ! qpdf --check "$file" >/dev/null 2>&1; then
      log_error "PDF validation failed (qpdf --check): ${file##*/}"
      log_info "Suggestion: The PDF structure may be damaged. Consider using qpdf --check for details."
      return 1
    fi
    log_verbose "PDF validation passed: ${file##*/}"
  fi

  return 0
}

# Print batch summary statistics
print_batch_summary() {
  local end_time=$(date +%s)
  local elapsed=$((end_time - STATS_START_TIME))

  # Convert elapsed time to human-readable format
  local hours=$((elapsed / 3600))
  local minutes=$(( (elapsed % 3600) / 60 ))
  local seconds=$((elapsed % 60))

  local time_str=""
  if (( hours > 0 )); then
    time_str="${hours}h ${minutes}m ${seconds}s"
  elif (( minutes > 0 )); then
    time_str="${minutes}m ${seconds}s"
  else
    time_str="${seconds}s"
  fi

  # Calculate total savings
  local total_saved=0
  local avg_ratio=0
  local avg_savings=0

  if (( STATS_BYTES_IN > 0 )); then
    total_saved=$((STATS_BYTES_IN - STATS_BYTES_OUT))
    avg_ratio=$(awk -v out="$STATS_BYTES_OUT" -v in="$STATS_BYTES_IN" 'BEGIN{printf "%.2f", out/in}')
    avg_savings=$(awk -v out="$STATS_BYTES_OUT" -v in="$STATS_BYTES_IN" 'BEGIN{printf "%.1f", (1-out/in)*100}')
  fi

  echo
  echo "${C_BOLD}${C_GREEN}═══════════════════════════════════════════════════════════${C_RESET}"
  echo "${C_BOLD}                    Batch Summary${C_RESET}"
  echo "${C_BOLD}${C_GREEN}═══════════════════════════════════════════════════════════${C_RESET}"
  echo
  echo "${C_BOLD}Files:${C_RESET}"
  echo "  Total:      ${C_BOLD}${STATS_TOTAL}${C_RESET}"
  echo "  Processed:  ${C_GREEN}${STATS_PROCESSED}${C_RESET}"
  echo "  Skipped:    ${C_YELLOW}${STATS_SKIPPED}${C_RESET}"
  echo "  Failed:     ${C_RED}${STATS_FAILED}${C_RESET}"
  echo

  if (( STATS_PROCESSED > 0 )); then
    echo "${C_BOLD}Compression:${C_RESET}"
    echo "  Input size:      $(fmt_bytes "$STATS_BYTES_IN")"
    echo "  Output size:     $(fmt_bytes "$STATS_BYTES_OUT")"
    echo "  Space saved:     ${C_GREEN}$(fmt_bytes "$total_saved")${C_RESET} (${C_BOLD}${avg_savings}%${C_RESET})"
    echo "  Avg ratio:       ${avg_ratio}"
    echo
  fi

  echo "${C_BOLD}Time:${C_RESET}"
  echo "  Total:       ${time_str}"
  if (( STATS_PROCESSED > 0 )); then
    local avg_time=$((elapsed / STATS_PROCESSED))
    echo "  Per file:    ${avg_time}s avg"
  fi
  echo
  echo "${C_BOLD}${C_GREEN}═══════════════════════════════════════════════════════════${C_RESET}"
  echo
}

gs_pass() {
  local in="$1" out="$2" jpegq="$3" deterministic="$4" C_RES="$5" G_RES="$6" M_RES="$7" mem_limit="${8:-}"

  local -a GS_COMMON
  GS_COMMON=(
    -sDEVICE=pdfwrite -dCompatibilityLevel=1.6
    -dCompressFonts=true -dSubsetFonts=true -dEmbedAllFonts=true
    -dAutoRotatePages=/None
    -dColorConversionStrategy=/LeaveColorUnchanged
    -dAutoFilterColorImages=true -dAutoFilterGrayImages=true
    -dEncodeColorImages=true -dEncodeGrayImages=true -dEncodeMonoImages=true
    -dNOPAUSE -dBATCH
  )

  # Apply memory limit if specified
  if [[ -n "$mem_limit" && "$mem_limit" -gt 0 ]]; then
    GS_COMMON+=(-dBufferSpace="$mem_limit")
  fi

  if (( C_RES > 0 )); then
    GS_COMMON+=(-dDownsampleColorImages=true -dColorImageDownsampleType=/Bicubic -dColorImageResolution="$C_RES")
  else
    GS_COMMON+=(-dDownsampleColorImages=false)
  fi

  if (( G_RES > 0 )); then
    GS_COMMON+=(-dDownsampleGrayImages=true -dGrayImageDownsampleType=/Bicubic -dGrayImageResolution="$G_RES")
  else
    GS_COMMON+=(-dDownsampleGrayImages=false)
  fi

  if (( M_RES > 0 )); then
    GS_COMMON+=(-dDownsampleMonoImages=true -dMonoImageDownsampleType=/Subsample -dMonoImageResolution="$M_RES")
  else
    GS_COMMON+=(-dDownsampleMonoImages=false)
  fi

  $deterministic && GS_COMMON+=(-dDeterministicIDs=true)
  [[ -n "$jpegq" && "$jpegq" -gt 0 ]] && GS_COMMON+=(-dJPEGQ="$jpegq")

  gs "${GS_COMMON[@]}" -sOutputFile="$out" -f "$in" >/dev/null 2>&1
}

gs_text_only_pass() {
  local in="$1" out="$2" deterministic="$3" mem_limit="${4:-}"

  local -a GS_TEXT_OPTS
  GS_TEXT_OPTS=(
    -sDEVICE=pdfwrite -dCompatibilityLevel=1.5
    -dCompressFonts=true -dSubsetFonts=true -dEmbedAllFonts=true
    -dAutoRotatePages=/None
    -dColorConversionStrategy=/LeaveColorUnchanged
    # Disable all image processing for text-only PDFs
    -dDownsampleColorImages=false
    -dDownsampleGrayImages=false
    -dDownsampleMonoImages=false
    -dAutoFilterColorImages=false
    -dAutoFilterGrayImages=false
    -dEncodeColorImages=false
    -dEncodeGrayImages=false
    -dEncodeMonoImages=false
    -dNOPAUSE -dBATCH
  )

  # Apply memory limit if specified
  [[ -n "$mem_limit" && "$mem_limit" -gt 0 ]] && GS_TEXT_OPTS+=(-dBufferSpace="$mem_limit")
  $deterministic && GS_TEXT_OPTS+=(-dDeterministicIDs=true)

  gs "${GS_TEXT_OPTS[@]}" -sOutputFile="$out" -f "$in" >/dev/null 2>&1
}

python_recompress_images() {
  local in="$1" out="$2" jpegq="$3" c_res="$4" g_res="$5"

  # 1) If caller provided an explicit helper path, use it
  if [[ -n "$PDF_DEFLYT_HELPER" && -x "$PDF_DEFLYT_HELPER" ]]; then
    helper="$PDF_DEFLYT_HELPER"
  else
    # 2) Resolve this script's directory in zsh reliably (works in Shortcuts)
    local this="${0:A}" 2>/dev/null || this="$0"
    local script_dir="${this:h}"
    local helper=""
    # 3) Search order: alongside script, then CWD, then PATH
    if [[ -x "$script_dir/pdf-deflyt-image-recompress" ]]; then
      helper="$script_dir/pdf-deflyt-image-recompress"
    elif [[ -x "./pdf-deflyt-image-recompress" ]]; then
      helper="./pdf-deflyt-image-recompress"
    elif helper="$(command -v pdf-deflyt-image-recompress 2>/dev/null)"; then
      :
    else
      return 1
    fi
  fi

  local verbose_flag=""
  [[ "${DEBUG:-false}" == true ]] && verbose_flag="-v"

  # Build DPI arguments as array
  local -a dpi_args=()
  [[ -n "$c_res" && "$c_res" -gt 0 ]] && dpi_args+=(--color-dpi "$c_res")
  [[ -n "$g_res" && "$g_res" -gt 0 ]] && dpi_args+=(--gray-dpi "$g_res")

  "$helper" $verbose_flag -q "${jpegq:-75}" "${dpi_args[@]}" "$in" "$out" 2>&1
}

estimate_savings() {
  local preset="$1" no_images="$2" c_cnt="$3" g_cnt="$4" m_cnt="$5" \
        c_med="$6" g_med="$7" m_med="$8" c_res="$9" g_res="${10}" m_res="${11}" jpegq="${12}"

  local base_low=1 base_high=6
  if [[ "$preset" == "lossless" || "$no_images" == "true" ]]; then
    echo "$base_low $base_high"; return
  fi

  f() { awk -v t="$1" -v m="$2" 'BEGIN{if(m<=0||t>=m){print 0}else{r=t/m; if(r<0)r=0; s=r*r; print (1-s)*100}}'; }
  local c_gain=0 g_gain=0 mono_gain=0
  (( c_cnt > 0 )) && c_gain=$(f "$c_res" "$c_med")
  (( g_cnt > 0 )) && g_gain=$(f "$g_res" "$g_med")

  if (( m_cnt > 0 )); then
    if (( m_med > 0 && m_res > 0 && m_res < m_med )); then
      mono_gain=$(f "$m_res" "$m_med")
      mono_gain=$(awk -v g="$mono_gain" 'BEGIN{print g+20}')
    else
      mono_gain=20
    fi
    mono_gain=$(awk -v g="$mono_gain" 'BEGIN{if(g<10)g=10; if(g>60)g=60; print g}')
  fi

  local total=$(( c_cnt + g_cnt + m_cnt )); (( total==0 )) && { echo "$base_low $base_high"; return; }
  local wC=$(awk -v n="$c_cnt" -v t="$total" 'BEGIN{print (t>0)?n/t:0}')
  local wG=$(awk -v n="$g_cnt" -v t="$total" 'BEGIN{print (t>0)?n/t:0}')
  local wM=$(awk -v n="$m_cnt" -v t="$total" 'BEGIN{print (t>0)?n/t:0}')
  local img_gain=$(awk -v c="$c_gain" -v g="$g_gain" -v m="$mono_gain" -v wC="$wC" -v wG="$wG" -v wM="$wM" \
                   'BEGIN{print c*wC + g*wG + m*wM}')

  local q_bonus=0
  if (( jpegq <= 68 )); then q_bonus=8
  elif (( jpegq <= 72 )); then q_bonus=4
  else q_bonus=2
  fi

  local mid=$(awk -v bL="$base_low" -v bH="$base_high" -v i="$img_gain" -v qb="$q_bonus" \
              'BEGIN{print ( (bL+bH)/2 + i + qb )}')
  mid=$(awk -v m="$mid" 'BEGIN{if(m<3)m=3; if(m>80)m=80; print m}')
  local low=$(awk -v m="$mid" 'BEGIN{print (m*0.7)}')
  local high=$(awk -v m="$mid" 'BEGIN{print (m*1.3>90?90:m*1.3)}')
  printf '%.1f %.1f\n' "$low" "$high"
}

SKIP_UNDER_RESOLVED=""; [[ -n "$SKIP_UNDER_BYTES" ]] && SKIP_UNDER_RESOLVED="$(parse_bytes "$SKIP_UNDER_BYTES")"

process_one() {
  emulate -L zsh
  unsetopt nounset

  local IN="${1-}" OUT_REQ="${2-}" PRE="${3-}" JQ="${4-}" INP="${5-}" \
        KEEP_META="${6-}" KEEP_DT="${7-}" MINGAIN="${8-}" DETER="${9-}" \
        PASS="${10-}" HOOK="${11-}" SC="${12-}"

  if [[ -z "$IN" ]]; then
    print -u2 "INTERNAL ERROR: process_one called without input path"
    return 2
  fi

  local orig="$IN"
  local base="${IN%.*}"
  if [[ -z "$OUT_REQ" ]]; then
    local default_out="${base}_deflyt.pdf"
    OUT="$(unique_filename "$default_out")"
  else
    OUT="$OUT_REQ"
  fi

  if $DEBUG; then
    printf 'DEBUG: IN="%s" OUT="%s" PRESET=%s\n' "$IN" "$OUT" "$PRE"
  fi

  # Handle encryption
  local encrypted="no"
  if [[ -n "$PASS" ]]; then
    local tmpdir="${TMPDIR:-/tmp}"
    tmpdir="${tmpdir%/}"
    local dec="$(mktemp "$tmpdir/pdf-deflyt.dec.XXXXXXXX.pdf")"
    chmod 600 "$dec"  # Restrict permissions immediately
    if qpdf --password="$PASS" --decrypt "$IN" "$dec" >/dev/null 2>&1; then
      IN="$dec"
      trap "rm -f '$dec' 2>/dev/null || true" EXIT
    else
      rm -f "$dec" 2>/dev/null || true
      log "SKIP: $orig (incorrect password)"
      return 1
    fi
  else
    if pdfinfo "$IN" 2>/dev/null | command egrep -qi '^Encrypted:\s*yes'; then
      log "SKIP: $IN (encrypted - use --password or --password-file to process)"
      return 1
    fi
  fi

  local atime mtime
  if $KEEP_DT; then
    atime=$(stat_time "$orig" atime)
    mtime=$(stat_time "$orig" mtime)
  fi

  if [[ ! -r "$IN" ]]; then
    log "SKIP (unreadable): $IN"
    return 2
  fi

  local dir="$(dirname "$IN")"
  # Strip trailing slash from TMPDIR to avoid double-slash issues with mktemp
  local tmpdir="${TMPDIR:-/tmp}"
  tmpdir="${tmpdir%/}"
  local tmp1="$(mktemp "$tmpdir/pdf-deflyt.opt.XXXXXXXX.pdf")"
  local tmp2="$(mktemp "$tmpdir/pdf-deflyt.gs.XXXXXXXX.pdf")"
  local tmp3="$(mktemp "$tmpdir/pdf-deflyt.fin.XXXXXXXX.pdf")"
  chmod 600 "$tmp1" "$tmp2" "$tmp3"

  setopt localtraps
  cleanup() {
    # Clean up all temp files, including intermediate files from failed operations
    rm -f "$tmp1" "$tmp2" "$tmp3" "${tmp3}.w" "${tmp3}.c" 2>/dev/null || true
    # If decrypted file exists in this scope, clean it up too
    [[ -n "${dec:-}" && -f "$dec" ]] && rm -f "$dec" 2>/dev/null || true
  }
  trap 'cleanup' EXIT INT TERM

  local ORIG_BYTES=$(size_of "$orig")

  # Structural optimization
  if ! pdfcpu optimize -quiet "$IN" "$tmp1" >/dev/null 2>&1; then
    if [[ -r "$IN" ]]; then
      cp "$IN" "$tmp1"
    else
      log "SKIP (optimize failed): $IN"
      return 2
    fi
  fi

  # Check if pdfcpu made file bigger (indicates already-optimized PDF)
  local TMP1_BYTES=$(size_of "$tmp1")
  local PDFCPU_MADE_BIGGER=false
  if (( TMP1_BYTES > ORIG_BYTES )); then
    PDFCPU_MADE_BIGGER=true
    # Revert to original if pdfcpu made it bigger
    cp "$IN" "$tmp1"
  fi

  # Analyze images
  read -r C_CNT G_CNT M_CNT C_MED G_MED M_MED C_MIN G_MIN M_MIN <<<"$(analyse_pdf "$tmp1")"
  local NO_IMAGES=false; (( C_CNT + G_CNT + M_CNT == 0 )) && NO_IMAGES=true

  # Determine compression targets
  local C_RES=200 G_RES=200 M_RES=900 JPEGQ=74 PRE_EFF="$PRE"
  case "$PRE" in
    light)       C_RES=300; G_RES=300; M_RES=1200; JPEGQ=78 ;;
    extreme)     C_RES=144; G_RES=144; M_RES=600;  JPEGQ=68 ;;
    lossless)    C_RES=0;   G_RES=0;   M_RES=0 ;;
    standard)
      # Smart detection: if no images, optimize for text-only
      if [[ "$NO_IMAGES" == true ]]; then
        C_RES=0; G_RES=0; M_RES=0; JPEGQ=0
      else
        if (( C_CNT > 0 )); then
          local target=$(( ${C_MED%.*} >= 380 ? 220 : 200 ))
          C_RES=$(( target > 150 ? target : 150 ))
        fi
        if (( G_CNT > 0 )); then
          local target=$(( ${G_MED%.*} >= 380 ? 220 : 200 ))
          G_RES=$(( target > 150 ? target : 150 ))
        fi
        if (( M_CNT > 0 )); then M_RES=$(( ${M_MED%.*} >= 900 ? 900 : 600 )); fi
        if (( C_CNT + G_CNT > 0 )); then JPEGQ=$(( (${C_MED%.*}+${G_MED%.*} >= 700) ? 68 : 72 )); fi
      fi
      ;;
    *) echo "Unknown preset: $PRE" >&2; return 2 ;;
  esac

  if $DEBUG; then
    read -r EST_LOW EST_HIGH <<<"$(estimate_savings "$PRE" "$NO_IMAGES" "$C_CNT" "$G_CNT" "$M_CNT" "$C_MED" "$G_MED" "$M_MED" "$C_RES" "$G_RES" "$M_RES" "$JPEGQ")"
    printf "  Images: C(cnt=%s med=%.0f min=%.0f) G(cnt=%s med=%.0f min=%.0f) M(cnt=%s med=%.0f min=%.0f)\n" \
      "$C_CNT" "$C_MED" "$C_MIN" "$G_CNT" "$G_MED" "$G_MIN" "$M_CNT" "$M_MED" "$M_MIN"
    printf "  Targets: C_RES=%s G_RES=%s M_RES=%s JPEGQ=%s\n" "$C_RES" "$G_RES" "$M_RES" "$JPEGQ"
    printf "  Est. savings: %s–%s%%\n" "$EST_LOW" "$EST_HIGH"
    pdfimages -list "$tmp1" 2>/dev/null | tail -n +3 | head -10
    return 0
  fi

  # Detect ICC profile images (more robust detection)
  # ICC images often have encoding that Ghostscript can corrupt, so we use ImageMagick instead
  local HAS_ICC=false
  local icc_check
  if icc_check="$(pdfimages -list "$tmp1" 2>/dev/null)"; then
    # Check if any image has ICC color profile (look for 'icc' in the color column)
    # Parse header to find color column, then check data rows
    if print -r -- "$icc_check" | awk '
      BEGIN { color_col=0; found=0 }
      /^page[[:space:]]+num[[:space:]]+type/ {
        for (i=1; i<=NF; i++) {
          if ($i == "color") { color_col=i; break }
        }
        next
      }
      /^-+/ { next }
      {
        if (color_col > 0 && NF >= color_col) {
          if (tolower($color_col) == "icc") {
            found=1
            exit
          }
        }
      }
      END { exit (found ? 0 : 1) }
    '; then
      HAS_ICC=true
    fi
  fi

  # Image compression
  if [[ "$PRE" == "lossless" ]]; then
    cp "$tmp1" "$tmp2"
  elif [[ "$NO_IMAGES" == true ]]; then
    # Text-only PDF: use Ghostscript for font optimization unless already well-optimized
    if $PDFCPU_MADE_BIGGER; then
      # PDF is already well-optimized, skip further processing
      $DEBUG && log "Text-only PDF already well-optimized (pdfcpu made it bigger), skipping Ghostscript"
      cp "$tmp1" "$tmp2"
    elif ! gs_text_only_pass "$tmp1" "$tmp2" "$DETERMINISTIC" "$MEMORY_LIMIT_BYTES"; then
      $DEBUG && log "WARNING: Text-only Ghostscript optimization failed, using structural compression only"
      cp "$tmp1" "$tmp2"
    fi
  elif $HAS_ICC; then
    log "NOTICE: Detected ICC profile images, using ImageMagick-based compression"
    # Repair PDF with qpdf before ICC processing to fix any xref issues from pdfcpu
    local tmp1_repaired="${tmp1}.repaired"
    if qpdf "$tmp1" "$tmp1_repaired" >/dev/null 2>&1; then
      mv "$tmp1_repaired" "$tmp1"
    fi
    if ! python_recompress_images "$tmp1" "$tmp2" "$JPEGQ" "$C_RES" "$G_RES"; then
      log "WARNING: ImageMagick not found - using structural compression only (1-5% typical savings)"
      log "         Install ImageMagick for better compression: brew install imagemagick"
      cp "$tmp1" "$tmp2"
    fi
  elif (( (C_CNT > 0 && ${C_MIN%.*} > 0 && ${C_MIN%.*} < C_RES) || \
          (G_CNT > 0 && ${G_MIN%.*} > 0 && ${G_MIN%.*} < G_RES) )); then
    log "NOTICE: Images below target resolution, using structural compression only"
    cp "$tmp1" "$tmp2"
  else
    if ! gs_pass "$tmp1" "$tmp2" "$JPEGQ" "$DETERMINISTIC" "$C_RES" "$G_RES" "$M_RES" "$MEMORY_LIMIT_BYTES"; then
      log "WARNING: Ghostscript compression failed, using structural compression only"
    fi
    [[ ! -s "$tmp2" ]] && cp "$tmp1" "$tmp2"
  fi

  # Final optimization (skip for already-optimized text-only PDFs)
  if [[ "$PDFCPU_MADE_BIGGER" == true && "$NO_IMAGES" == true ]]; then
    # Already well-optimized, skip final processing to avoid bloat
    cp "$tmp2" "$tmp3"
    $DEBUG && log "Skipping final optimization for already-optimized text-only PDF"
  else
    if ! pdfcpu optimize -quiet "$tmp2" "$tmp3" >/dev/null 2>&1; then
      [[ -s "$tmp2" ]] && cp "$tmp2" "$tmp3" || cp "$tmp1" "$tmp3"
    fi
    if $LINEARIZE; then
      if ! qpdf --linearize "$tmp3" "${tmp3}.w" >/dev/null 2>&1 || ! mv "${tmp3}.w" "$tmp3" 2>/dev/null; then
        $DEBUG && log "WARNING: QPDF linearization failed, continuing without linearization"
        rm -f "${tmp3}.w" 2>/dev/null || true
      fi
    fi
    if ! mutool clean -z "$tmp3" "${tmp3}.c" >/dev/null 2>&1 || ! mv "${tmp3}.c" "$tmp3" 2>/dev/null; then
      $DEBUG && log "WARNING: MuPDF clean failed, continuing without additional cleaning"
      rm -f "${tmp3}.c" 2>/dev/null || true
    fi
  fi
  # Metadata and timestamps are always preserved (KEEP_METADATA=true, KEEP_DATE=true)

  local OUT_BYTES=$(size_of "$tmp3")
  local SAVEPCT=$(awk -v a="$OUT_BYTES" -v b="$ORIG_BYTES" 'BEGIN{printf "%.2f",(b>0)?(100*(1-a/b)):0}')
  local replace_ok=$(awk -v s="$SAVEPCT" -v m="$MINGAIN" -v a="$OUT_BYTES" -v b="$ORIG_BYTES" 'BEGIN{print (a<b && s>=m)?1:0}')
  local note="ok"

  # Validate compressed PDF before using it
  if ! validate_pdf "$tmp3"; then
    log_error "Compressed PDF failed validation, keeping original: ${orig##*/}"
    note="validation-failed"
    replace_ok=0
  fi

  if [[ "$replace_ok" -eq 1 ]]; then
    if $INPLACE; then
      # Create backup if requested
      if $BACKUP; then
        local backup_file="${orig}.bak"
        if cp "$orig" "$backup_file" 2>/dev/null; then
          log_verbose "Created backup: ${backup_file##*/}"
        else
          log_warn "Failed to create backup file: $backup_file"
        fi
      fi
      mv "$tmp3" "$orig"
      $KEEP_DT && restore_times "$orig" "$orig"
      OUT="$orig"
    else
      mv "$tmp3" "$OUT"
      $KEEP_DT && restore_times "$orig" "$OUT"
    fi
  else
    note="kept-original"
    ! $INPLACE && cp "$orig" "$OUT"
  fi

  if $SIDECAR; then
    sha_sidecar pre "$orig" || log "WARNING: Failed to create pre-compression SHA256 sidecar"
    sha_sidecar post "$OUT" || log "WARNING: Failed to create post-compression SHA256 sidecar"
  fi

  if [[ -n "$POST_HOOK" ]]; then
    cmd=${POST_HOOK//\{\}/${(q)OUT}}
    if ! env IN="$orig" OUT="$OUT" ORIG_BYTES="$ORIG_BYTES" OUT_BYTES="$OUT_BYTES" \
             PRESET="$PRE" SAVEPCT="$SAVEPCT" /bin/zsh -lc -- "$cmd"; then
      log "WARNING: Post-hook command failed: $cmd"
    fi
  fi

  if [[ -n "$LOGFILE" ]]; then
    local ratio=$(awk -v a="$OUT_BYTES" -v b="$ORIG_BYTES" 'BEGIN{printf "%.4f",(b>0)?a/b:1}')
    printf '%s,%s,%s,%.4f,%s,%s\n' "$orig" "$ORIG_BYTES" "$OUT_BYTES" "$ratio" "$PRE" "$note" >> "$LOGFILE"
  fi

  # Update batch statistics (only in sequential mode, not in worker processes)
  if ! $INTERNAL_ONE; then
    ((STATS_TOTAL++))
    if [[ "$note" == "ok" || "$note" == "kept-original" || "$note" == "validation-failed" ]]; then
      ((STATS_PROCESSED++))
      ((STATS_BYTES_IN += ORIG_BYTES))
      ((STATS_BYTES_OUT += OUT_BYTES))
    fi
  fi

  $QUIET || printf '→ %s  (%.1f%% smaller)  [%s]\n' "$OUT" "$SAVEPCT" "$note"
  cleanup
}

run_wrapper() {
  emulate -L zsh
  local f="$1" out="${2-}"

  if [[ -z "$f" ]]; then
    log "SKIP (empty path)"
    ! $INTERNAL_ONE && ((STATS_TOTAL++)) && ((STATS_SKIPPED++))
    return 0
  fi

  if [[ ! -r "$f" ]]; then
    log "SKIP (unreadable): $f"
    ! $INTERNAL_ONE && ((STATS_TOTAL++)) && ((STATS_SKIPPED++))
    return 0
  fi

  if [[ -n "${SKIP_UNDER_RESOLVED:-}" ]]; then
    local sz=$(size_of "$f")
    if [[ -n "$sz" && "$sz" -lt "$SKIP_UNDER_RESOLVED" ]]; then
      log "SKIP (too small): $f"
      ! $INTERNAL_ONE && ((STATS_TOTAL++)) && ((STATS_SKIPPED++))
      return 0
    fi
  fi

  if [[ "${DRYRUN:-false}" == true ]]; then
    local tmpdir="${TMPDIR:-/tmp}"
    tmpdir="${tmpdir%/}"
    local tmp1="$(mktemp "$tmpdir/pdf-deflyt.dry.XXXXXXXX.pdf")"
    local ORIG_BYTES=$(size_of "$f")

    pdfcpu optimize -quiet "$f" "$tmp1" >/dev/null 2>&1 || cp "$f" "$tmp1" || { echo "DRY: $f (unreadable)"; return 0; }

    read -r C_CNT G_CNT M_CNT C_MED G_MED M_MED C_MIN G_MIN M_MIN <<<"$(analyse_pdf "$tmp1")"
    local NO_IMAGES=false; (( C_CNT + G_CNT + M_CNT == 0 )) && NO_IMAGES=true

    local C_RES=200 G_RES=200 M_RES=900 JPEGQ=74
    case "$PRESET" in
      light)       C_RES=300; G_RES=300; M_RES=1200; JPEGQ=78 ;;
      extreme)     C_RES=144; G_RES=144; M_RES=600;  JPEGQ=68 ;;
      archive)     C_RES=240; G_RES=240; M_RES=900;  JPEGQ=74 ;;
      lossless)    C_RES=0;   G_RES=0;   M_RES=0;    JPEGQ=74 ;;
      aggressive)  C_RES=0;   G_RES=0;   M_RES=0;    JPEGQ=75 ;;
      standard)
        if (( C_CNT > 0 )); then
          local target=$(( ${C_MED%.*} >= 380 ? 220 : 200 ))
          C_RES=$(( target > 150 ? target : 150 ))
        fi
        if (( G_CNT > 0 )); then
          local target=$(( ${G_MED%.*} >= 380 ? 220 : 200 ))
          G_RES=$(( target > 150 ? target : 150 ))
        fi
        if (( M_CNT > 0 )); then M_RES=$(( ${M_MED%.*} >= 900 ? 900 : 600 )); fi
        JPEGQ=${JPEGQ_OVERRIDE:-74}
        ;;
    esac

    read -r EST_LOW EST_HIGH <<<"$(estimate_savings "$PRESET" "$NO_IMAGES" "$C_CNT" "$G_CNT" "$M_CNT" \
                                    "$C_MED" "$G_MED" "$M_MED" "$C_RES" "$G_RES" "$M_RES" "$JPEGQ")"

    local est_low_bytes=$(awk -v o="$ORIG_BYTES" -v p="$EST_HIGH" 'BEGIN{print (o*(100-p)/100)}')
    local est_high_bytes=$(awk -v o="$ORIG_BYTES" -v p="$EST_LOW"  'BEGIN{print (o*(100-p)/100)}')

    printf 'DRY: %s  preset=%s  est_savings≈%s–%s%%  est_size≈%s–%s (from %s)\n' \
        "$f" "$PRESET" "$EST_LOW" "$EST_HIGH" \
        "$(fmt_bytes "$est_low_bytes")" "$(fmt_bytes "$est_high_bytes")" \
        "$(fmt_bytes "$ORIG_BYTES")"

    rm -f "$tmp1" >/dev/null 2>&1 || true
    return 0
  fi

  # Call process_one and capture return code for statistics tracking
  local rc=0
  process_one "$f" "$out" "$PRESET" "$JPEGQ_OVERRIDE" "$INPLACE" "$KEEP_METADATA" "$KEEP_DATE" \
              "$MIN_GAIN" "$DETERMINISTIC" "$PASSWORD" "$POST_HOOK" "$SIDECAR" || rc=$?

  # Track failures and skips in statistics (only in sequential mode)
  if ! $INTERNAL_ONE; then
    if (( rc == 1 )); then
      ((STATS_TOTAL++))
      ((STATS_SKIPPED++))
    elif (( rc == 2 )); then
      ((STATS_TOTAL++))
      ((STATS_FAILED++))
    fi
  fi

  return $rc
}

if $INTERNAL_ONE; then
  f="${FILES[1]}"; run_wrapper "$f" "" || true; exit 0
fi
if [[ -n "$OUT_SINGLE" ]]; then
  run_wrapper "${FILES[1]}" "$OUT_SINGLE" || true; exit 0
fi

if (( JOBS > 1 )) && $PARALLEL_OK; then
  # GNU parallel mode (best performance)
  local total="${#FILES[@]}"
  $QUIET || (( total > 1 )) && log "Processing $total files in parallel (${JOBS} workers)..."

  env PRESET="$PRESET" JPEGQ_OVERRIDE="$JPEGQ_OVERRIDE" INPLACE="$INPLACE" \
      KEEP_METADATA="$KEEP_METADATA" KEEP_DATE="$KEEP_DATE" MIN_GAIN="$MIN_GAIN" \
      DETERMINISTIC="$DETERMINISTIC" PASSWORD="$PASSWORD" POST_HOOK="$POST_HOOK" \
      SIDECAR="$SIDECAR" DRYRUN="$DRYRUN" DEBUG="$DEBUG" \
      SKIP_UNDER_BYTES="$SKIP_UNDER_BYTES" SKIP_UNDER_RESOLVED="$SKIP_UNDER_RESOLVED" \
      MEMORY_LIMIT_BYTES="$MEMORY_LIMIT_BYTES" \
      LOGFILE="$LOGFILE" QUIET="$QUIET" \
  command parallel -j "$JOBS" --no-notice --will-cite -- \
    "$0" --internal-one {} ::: "${FILES[@]}"
elif (( JOBS > 1 )) && command -v xargs >/dev/null 2>&1 && echo test | xargs -P 1 echo >/dev/null 2>&1; then
  # xargs -P fallback mode (when GNU parallel is unavailable)
  local total="${#FILES[@]}"
  $QUIET || (( total > 1 )) && log "Processing $total files in parallel using xargs (${JOBS} workers)..."

  # Export variables for child processes
  export PRESET JPEGQ_OVERRIDE INPLACE KEEP_METADATA KEEP_DATE MIN_GAIN \
         DETERMINISTIC PASSWORD POST_HOOK SIDECAR DRYRUN DEBUG \
         SKIP_UNDER_BYTES SKIP_UNDER_RESOLVED MEMORY_LIMIT_BYTES LOGFILE QUIET

  # Use xargs -P for parallel processing
  printf '%s\0' "${FILES[@]}" | \
    xargs -0 -P "$JOBS" -I {} "$0" --internal-one {}
else
  # Sequential fallback mode
  local total="${#FILES[@]}"
  local current=0

  # Initialize batch statistics
  STATS_START_TIME=$(date +%s)
  STATS_TOTAL=0
  STATS_PROCESSED=0
  STATS_SKIPPED=0
  STATS_FAILED=0
  STATS_BYTES_IN=0
  STATS_BYTES_OUT=0

  for f in "${FILES[@]}"; do
    (( current = current + 1 ))
    if ! $QUIET && (( total > 1 )); then
      local basename="${f##*/}"
      local pct=$(awk -v c="$current" -v t="$total" 'BEGIN{printf "%.0f", (c/t)*100}')
      printf '[%3d%%] (%d/%d) %s\n' "$pct" "$current" "$total" "$basename" >&2
    fi
    run_wrapper "$f" "" || true
  done

  # Print batch summary if processing multiple files
  if (( total > 1 )) && ! $QUIET && ! $DRYRUN; then
    print_batch_summary
  fi
fi
