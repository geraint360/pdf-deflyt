#!/bin/zsh
set -e
set -o pipefail

# pdf-deflyt v2.3.0-zsh
# - Auto-tuned compression via image PPI analysis
# - Presets: light, standard, extreme, lossless, archive
# - Batch + recurse + parallel processing
# - Special handling for ICC profile images via ImageMagick
# - Metadata & timestamps preserved by default
#
# Dependencies (Homebrew):
#   brew install ghostscript pdfcpu qpdf mupdf exiftool poppler coreutils imagemagick
#   brew install parallel  # optional, for parallel processing
#
# For ICC profile image support:
#   - ImageMagick is required (brew install imagemagick)
#   - Helper script pdf-deflyt-image-recompress must be in same directory
#   - Python dependencies are auto-managed by the helper (no manual setup)

usage() {
  cat <<'EOF'
Usage:
  pdf-deflyt [OPTIONS] INPUT...

Presets:
  -p standard   (default) Auto-tuned per-PDF targets
  -p light      C/G 300dpi; mono 1200dpi; JPEG Q~78
  -p extreme    C/G 144dpi; mono 600dpi; JPEG Q~68
  -p lossless   Structure-only; no image recompression
  -p archive    C/G 240dpi; mono 900dpi; deterministic; strips metadata

Key Options:
  --recurse                 Recurse for *.pdf
  --jobs N                  Parallel workers (requires GNU parallel)
  --inplace                 Replace originals atomically
  -o OUT                    Single output path (single input only)
  -q N                      Force JPEG quality 1..100
  --min-gain PCT            Skip if savings < PCT (default 1)
  --skip-if-smaller SIZE    Skip files below SIZE (e.g. 200K, 1.5MB)
  --dry-run                 Analyze only; show estimated savings
  --debug                   Show parameters and verbose output
  --check-deps              Verify dependencies

Metadata/Timestamps:
  --keep-metadata (default) | --strip-metadata
  --keep-date (default)     | --no-keep-date

Security:
  --password TEXT | --password-file FILE

Determinism/Logs:
  --deterministic (default) | --no-deterministic
  --log CSV

Filtering (regex on full path):
  --exclude REGEX (repeatable)
  --include REGEX (repeatable)

Sidecars & Hooks:
  --sidecar-sha256
  --post-hook 'CMD {}'       (env: IN, OUT, ORIG_BYTES, OUT_BYTES, PRESET, SAVEPCT)
EOF
  exit 2
}

# ============================================================================
# Configuration Constants (immutable)
# ============================================================================
readonly VERSION="2.3.0-zsh"
readonly IMAGEMAGICK_TIMEOUT=30  # seconds for ImageMagick operations
readonly PYMUPDF_GARBAGE_LEVEL=4  # PyMuPDF garbage collection level
readonly APFS_TIME_TOLERANCE=120   # seconds tolerance for timestamp preservation

# Dependency lists
readonly -a REQUIRED_DEPS=(gs pdfcpu qpdf mutool exiftool pdfinfo pdfimages sha256sum gstat)
readonly -a REQUIRED_PKGS=('ghostscript' 'pdfcpu' 'qpdf' 'mupdf' 'exiftool' 'poppler' 'poppler' 'coreutils' 'coreutils')
readonly -a OPTIONAL_DEPS=(parallel magick)
readonly -a OPTIONAL_PKGS=('parallel' 'imagemagick')

# Helper script path (can be overridden via environment: export PDF_DEFLYT_HELPER=/path/to/helper)
: "${PDF_DEFLYT_HELPER:=}"

# ============================================================================
# Runtime Configuration (set by command-line arguments)
# ============================================================================

# File lists and filters
typeset -a ARGS FILES EXCLUDES INCLUDES

# Compression settings
PRESET="standard"
JPEGQ_OVERRIDE=""

# Output options
OUT_SINGLE=""
INPLACE=false

# Processing mode
RECURSE=false
JOBS=1
DRYRUN=false
DEBUG=false
CHECK_DEPS=false

# Logging
LOGFILE=""
QUIET=${QUIET:-false}

# File filtering
MIN_GAIN=1
SKIP_UNDER_BYTES=""

# Metadata and timestamps
KEEP_METADATA=true
KEEP_DATE=true
DETERMINISTIC=true

# Security
PASSWORD=""
PASSWORD_FILE=""

# Hooks and sidecars
POST_HOOK=""
SIDECAR=false

# Internal flags
INTERNAL_ONE=false

log() { $QUIET || printf '%s\n' "$@"; }

while [[ $# -gt 0 ]]; do
  case "$1" in
    -p) PRESET="${2:-}"; shift 2 ;;
    -o) OUT_SINGLE="${2:-}"; shift 2 ;;
    -q) JPEGQ_OVERRIDE="${2:-}"; shift 2 ;;
    --recurse) RECURSE=true; shift ;;
    --jobs) JOBS="${2:-1}"; shift 2 ;;
    --inplace) INPLACE=true; shift ;;
    --dry-run) DRYRUN=true; shift ;;
    --debug) DEBUG=true; shift ;;
    --log) LOGFILE="${2:-}"; shift 2 ;;
    --min-gain) MIN_GAIN="${2:-1}"; shift 2 ;;
    --skip-if-smaller) SKIP_UNDER_BYTES="${2:-}"; shift 2 ;;
    --keep-metadata) KEEP_METADATA=true; shift ;;
    --strip-metadata) KEEP_METADATA=false; shift ;;
    --keep-date) KEEP_DATE=true; shift ;;
    --no-keep-date) KEEP_DATE=false; shift ;;
    --deterministic) DETERMINISTIC=true; shift ;;
    --no-deterministic) DETERMINISTIC=false; shift ;;
    --password) PASSWORD="${2:-}"; shift 2 ;;
    --password-file) PASSWORD_FILE="${2:-}"; shift 2 ;;
    --post-hook) POST_HOOK="${2:-}"; shift 2 ;;
    --sidecar-sha256) SIDECAR=true; shift ;;
    --quiet) QUIET=true; shift ;;
    --exclude) EXCLUDES+=("${2:-}"); shift 2 ;;
    --include) INCLUDES+=("${2:-}"); shift 2 ;;
    --internal-one) INTERNAL_ONE=true; shift ;;
    --check-deps) CHECK_DEPS=true; shift ;;
    --help|-h) usage ;;
    --version) echo "$VERSION"; exit 0 ;;
    --) shift; break ;;
    -*) echo "Unknown option: $1" >&2; usage ;;
    *) ARGS+=("$1"); shift ;;
  esac
done

[[ ${#ARGS[@]} -ge 1 || $INTERNAL_ONE = true || $CHECK_DEPS = true ]] || usage
if [[ -n "$OUT_SINGLE" && ${#ARGS[@]} -ne 1 && $INTERNAL_ONE = false ]]; then
  echo "ERROR: -o option requires exactly one input file (got ${#ARGS[@]})" >&2
  exit 2
fi

# Validate password file
if [[ -n "$PASSWORD_FILE" ]]; then
  if [[ ! -f "$PASSWORD_FILE" ]]; then
    echo "ERROR: Password file not found: $PASSWORD_FILE" >&2
    exit 2
  fi
  if [[ ! -r "$PASSWORD_FILE" ]]; then
    echo "ERROR: Cannot read password file: $PASSWORD_FILE" >&2
    exit 2
  fi
  PASSWORD="$(/usr/bin/head -n1 "$PASSWORD_FILE" 2>/dev/null || true)"
  if [[ -z "$PASSWORD" ]]; then
    echo "ERROR: Password file is empty: $PASSWORD_FILE" >&2
    exit 2
  fi
fi

# Validate JPEG quality
if [[ -n "$JPEGQ_OVERRIDE" ]]; then
  if ! [[ "$JPEGQ_OVERRIDE" =~ ^[0-9]+$ ]] || (( JPEGQ_OVERRIDE < 1 || JPEGQ_OVERRIDE > 100 )); then
    echo "ERROR: JPEG quality must be between 1 and 100 (got: $JPEGQ_OVERRIDE)" >&2
    exit 2
  fi
fi

# Validate jobs parameter
if ! [[ "$JOBS" =~ ^[0-9]+$ ]] || (( JOBS < 1 )); then
  echo "ERROR: --jobs must be a positive integer (got: $JOBS)" >&2
  exit 2
fi

check_deps() {
  local -a REQ_CMDS REQ_DESC OPT_CMDS OPT_DESC
  REQ_CMDS=("${REQUIRED_DEPS[@]}")
  REQ_DESC=("${REQUIRED_PKGS[@]}")
  OPT_CMDS=("${OPTIONAL_DEPS[@]}")
  OPT_DESC=("${OPTIONAL_PKGS[@]}")

  local missing=0

  printf "%-12s  %-10s  %s\n" "COMMAND" "STATUS" "HOMEBREW PACKAGE"
  printf "%-12s  %-10s  %s\n" "--------" "------" "------------------"

  local i=1
  for cmd in "${REQ_CMDS[@]}"; do
    local pkg="${REQ_DESC[$i]}"; ((i++))
    if command -v "$cmd" >/dev/null 2>&1; then
      printf "%-12s  %-10s  %s\n" "$cmd" "OK" "$pkg"
    else
      printf "%-12s  %-10s  %s\n" "$cmd" "MISSING" "$pkg"
      missing=1
    fi
  done

  local j=1
  while (( j <= ${#OPT_CMDS[@]} )); do
    local ocmd="${OPT_CMDS[$j]}"
    local opkg="${OPT_DESC[$j]}"
    if command -v "$ocmd" >/dev/null 2>&1; then
      printf "%-12s  %-10s  %s (optional)\n" "$ocmd" "OK" "$opkg"
    else
      printf "%-12s  %-10s  %s (optional)\n" "$ocmd" "MISSING" "$opkg"
    fi
    ((j++))
  done

  echo
  echo "Install with:"
  echo "  brew install ghostscript pdfcpu qpdf mupdf exiftool poppler coreutils imagemagick parallel"

  return $missing
}

need() {
  command -v "$1" >/dev/null 2>&1 || {
    echo "ERROR: Missing required dependency: $1" >&2
    echo "Install with: brew install ghostscript pdfcpu qpdf mupdf exiftool poppler coreutils" >&2
    exit 127
  }
}
if $CHECK_DEPS; then check_deps; exit $?; fi

for t in pdfcpu qpdf mutool exiftool pdfinfo pdfimages gs sha256sum; do need "$t"; done
PARALLEL_OK=false; command -v parallel >/dev/null 2>&1 && PARALLEL_OK=true

is_pdf() { [[ "${1:l}" == *.pdf ]]; }
gather_one() {
  local in="$1"
  if [[ -d "$in" ]]; then
    if $RECURSE; then
      command find "$in" -type f \( -iname '*.pdf' -o -iname '*.PDF' \)
    else
      for f in "$in"/*; do [[ -f "$f" && "${f:l}" == *.pdf ]] && print -r -- "$f"; done
    fi
  elif [[ -f "$in" ]]; then
    print -r -- "$in"
  fi
}

if $INTERNAL_ONE; then FILES=("$1")
else
  FILES=()
  for x in "${ARGS[@]}"; do
    while IFS= read -r line; do
      FILES+=("$line")
    done < <(gather_one "$x")
  done
fi
[[ ${#FILES[@]} -ge 1 ]] || { echo "ERROR: No PDF files found in the specified location(s)" >&2; exit 1; }

if $DEBUG; then
  printf 'DEBUG: FILES(%d):\n' "${#FILES[@]}"
  for p in "${FILES[@]}"; do printf '  %s\n' "$p"; done
fi

filter_files() {
  local -a input; input=("$@"); local -a keep
  for f in "${input[@]}"; do
    [[ "${f:l}" == *.pdf ]] || continue
    local skip=false
    for pat in "${EXCLUDES[@]}"; do print -r -- "$f" | command grep -E -q -- "$pat" && { skip=true; break; }; done
    $skip && continue
    if (( ${#INCLUDES[@]} > 0 )); then
      local matched=false
      for pat in "${INCLUDES[@]}"; do print -r -- "$f" | command grep -E -q -- "$pat" && { matched=true; break; }; done
      $matched || continue
    fi
    keep+=("$f")
  done
  print -r -- "${keep[@]}" 2>/dev/null || true
}
if ! $INTERNAL_ONE; then
  FILES=("${(f)$(filter_files "${FILES[@]}")}")
  [[ ${#FILES[@]} -ge 1 ]] || { echo "ERROR: No PDF files remaining after applying filters" >&2; exit 1; }
fi

# Cross-platform stat helpers
size_of() {
  { command gstat -c%s "$1" 2>/dev/null || \
    stat -f%z "$1" 2>/dev/null || \
    stat -c%s "$1" 2>/dev/null; }
}

stat_time() {
  local file="$1" type="$2"  # type: atime or mtime
  case "$type" in
    atime) { command gstat -c %X "$file" 2>/dev/null || \
             stat -f %a "$file" 2>/dev/null || \
             stat -c %X "$file" 2>/dev/null; } ;;
    mtime) { command gstat -c %Y "$file" 2>/dev/null || \
             stat -f %m "$file" 2>/dev/null || \
             stat -c %Y "$file" 2>/dev/null; } ;;
    *) echo "0" ;;
  esac
}

restore_times() { touch -r "$1" "$2" 2>/dev/null || true; }

unique_filename() {
  local base="$1"
  local ext="${base##*.}"
  local name="${base%.*}"
  local candidate="$base"
  local counter=2
  while [[ -e "$candidate" ]]; do
    candidate="${name} (${counter}).${ext}"
    ((counter++))
  done
  echo "$candidate"
}

parse_bytes() {
  local s="${1:-}"; [[ -z "$s" ]] && { echo ""; return; }
  s="${s//[[:space:]]/}"; s="${s:u}"
  [[ "$s" =~ '^[0-9]+$' ]] && { echo "$s"; return; }
  if print -r -- "$s" | command grep -E -q '^[0-9]+(\.[0-9]+)?(K|KB|M|MB|G|GB)$'; then
    local n="${s%[KkMmGg][Bb]}" u="${s##*[0-9]}"
    case "$u" in
      K|KB) awk -v n="$n" 'BEGIN{printf "%.0f", n*1024}' ;;
      M|MB) awk -v n="$n" 'BEGIN{printf "%.0f", n*1024*1024}' ;;
      G|GB) awk -v n="$n" 'BEGIN{printf "%.0f", n*1024*1024*1024}' ;;
    esac; return
  fi
  echo "ERROR: Invalid SIZE format: '$1'. Expected format: 200K, 1.5MB, 2GB" >&2; exit 2
}

fmt_bytes() {
  local b="$1"
  awk -v b="$b" 'BEGIN{
    if (b<1024){printf "%d B", b; exit}
    kb=b/1024; if (kb<1024){printf "%.1f KB", kb; exit}
    mb=kb/1024; if (mb<1024){printf "%.2f MB", mb; exit}
    gb=mb/1024; printf "%.2f GB", gb
  }'
}

analyse_pdf() {
  local f="$1"
  local list
  if ! list="$(pdfimages -list "$f" 2>/dev/null)"; then
    echo "0 0 0 0 0 0 0 0 0"; return
  fi

  local parsed
  parsed=$(print -r -- "$list" | awk '
    function isgray(s,    t){ t=tolower(s); return (t=="gray" || t=="greyscale" || t=="grey") }
    function med(a, n,    i,j,tmp){
      if (n==0) return 0
      for (i=1;i<=n;i++) for (j=i+1;j<=n;j++) if (a[j] < a[i]) { tmp=a[i]; a[i]=a[j]; a[j]=tmp }
      return (n%2)? a[(n+1)/2] : (a[n/2]+a[n/2+1])/2
    }
    function minv(a, n,   i,m){
      if (n==0) return 0
      m=a[1]; for (i=2;i<=n;i++) if (a[i]<m) m=a[i]; return m
    }

    BEGIN {
      headerSeen=sepSeen=0
      xcol=ycol=colorcol=bpccol=0
      cN=gN=mN=0
    }

    /^page[[:space:]]+num[[:space:]]+type/ {
      headerSeen=1
      for (i=1; i<=NF; i++) {
        if ($i=="x-ppi") xcol=i
        else if ($i=="y-ppi") ycol=i
        else if ($i=="color") colorcol=i
        else if ($i=="bpc")   bpccol=i
      }
      next
    }

    /^-+/ { if (headerSeen) { sepSeen=1; next } }

    {
      if (!sepSeen || xcol==0 || ycol==0 || colorcol==0 || bpccol==0) next
      x=$xcol; y=$ycol; col=$colorcol; bpc=$bpccol
      if ((x+0)==0 && (y+0)==0) next

      ppi=(x+y)/2
      if (isgray(col)) {
        g[++gN]=ppi
      } else if (tolower(col)=="icc" || tolower(col)=="rgb" || tolower(col)=="cmyk") {
        c[++cN]=ppi
      } else if ((bpc+0)==1) {
        m[++mN]=ppi
      }
    }

    END {
      C_CNT=cN+0; G_CNT=gN+0; M_CNT=mN+0
      C_MED=med(c, C_CNT); G_MED=med(g, G_CNT); M_MED=med(m, M_CNT)
      C_MIN=minv(c, C_CNT); G_MIN=minv(g, G_CNT); M_MIN=minv(m, M_CNT)
      printf "%d %d %d %.0f %.0f %.0f %.0f %.0f %.0f\n",
             C_CNT, G_CNT, M_CNT, C_MED, G_MED, M_MED, C_MIN, G_MIN, M_MIN
    }')

  [[ -n "$parsed" ]] && echo "$parsed" || echo "0 0 0 0 0 0 0 0 0"
}

sha_sidecar() {
  local which="$1" file="$2"
  if ! sha256sum "$file" > "${file}.${which}.sha256" 2>/dev/null; then
    log "WARNING: Failed to create $which SHA256 sidecar for: ${file##*/}"
    return 1
  fi
  return 0
}

gs_pass() {
  local in="$1" out="$2" jpegq="$3" deterministic="$4" C_RES="$5" G_RES="$6" M_RES="$7"

  local -a GS_COMMON
  GS_COMMON=(
    -sDEVICE=pdfwrite -dCompatibilityLevel=1.6
    -dCompressFonts=true -dSubsetFonts=true -dEmbedAllFonts=true
    -dAutoRotatePages=/None
    -dColorConversionStrategy=/LeaveColorUnchanged
    -dAutoFilterColorImages=true -dAutoFilterGrayImages=true
    -dEncodeColorImages=true -dEncodeGrayImages=true -dEncodeMonoImages=true
    -dNOPAUSE -dBATCH
  )

  if (( C_RES > 0 )); then
    GS_COMMON+=(-dDownsampleColorImages=true -dColorImageDownsampleType=/Bicubic -dColorImageResolution="$C_RES")
  else
    GS_COMMON+=(-dDownsampleColorImages=false)
  fi

  if (( G_RES > 0 )); then
    GS_COMMON+=(-dDownsampleGrayImages=true -dGrayImageDownsampleType=/Bicubic -dGrayImageResolution="$G_RES")
  else
    GS_COMMON+=(-dDownsampleGrayImages=false)
  fi

  if (( M_RES > 0 )); then
    GS_COMMON+=(-dDownsampleMonoImages=true -dMonoImageDownsampleType=/Subsample -dMonoImageResolution="$M_RES")
  else
    GS_COMMON+=(-dDownsampleMonoImages=false)
  fi

  $deterministic && GS_COMMON+=(-dDeterministicIDs=true)
  [[ -n "$jpegq" && "$jpegq" -gt 0 ]] && GS_COMMON+=(-dJPEGQ="$jpegq")

  gs "${GS_COMMON[@]}" -sOutputFile="$out" -f "$in" >/dev/null 2>&1
}

python_recompress_images() {
  local in="$1" out="$2" jpegq="$3"

  # 1) If caller provided an explicit helper path, use it
  if [[ -n "$PDF_DEFLYT_HELPER" && -x "$PDF_DEFLYT_HELPER" ]]; then
    helper="$PDF_DEFLYT_HELPER"
  else
    # 2) Resolve this script’s directory in zsh reliably (works in Shortcuts)
    local this="${0:A}" 2>/dev/null || this="$0"
    local script_dir="${this:h}"
    local helper=""
    # 3) Search order: alongside script, then CWD, then PATH
    if [[ -x "$script_dir/pdf-deflyt-image-recompress" ]]; then
      helper="$script_dir/pdf-deflyt-image-recompress"
    elif [[ -x "./pdf-deflyt-image-recompress" ]]; then
      helper="./pdf-deflyt-image-recompress"
    elif helper="$(command -v pdf-deflyt-image-recompress 2>/dev/null)"; then
      :
    else
      return 1
    fi
  fi

  local verbose_flag=""
  [[ "${DEBUG:-false}" == true ]] && verbose_flag="-v"
  "$helper" $verbose_flag -q "${jpegq:-75}" "$in" "$out" 2>&1
}

estimate_savings() {
  local preset="$1" no_images="$2" c_cnt="$3" g_cnt="$4" m_cnt="$5" \
        c_med="$6" g_med="$7" m_med="$8" c_res="$9" g_res="${10}" m_res="${11}" jpegq="${12}"

  local base_low=1 base_high=6
  if [[ "$preset" == "lossless" || "$no_images" == "true" ]]; then
    echo "$base_low $base_high"; return
  fi

  f() { awk -v t="$1" -v m="$2" 'BEGIN{if(m<=0||t>=m){print 0}else{r=t/m; if(r<0)r=0; s=r*r; print (1-s)*100}}'; }
  local c_gain=0 g_gain=0 mono_gain=0
  (( c_cnt > 0 )) && c_gain=$(f "$c_res" "$c_med")
  (( g_cnt > 0 )) && g_gain=$(f "$g_res" "$g_med")
  
  if (( m_cnt > 0 )); then
    if (( m_med > 0 && m_res > 0 && m_res < m_med )); then
      mono_gain=$(f "$m_res" "$m_med")
      mono_gain=$(awk -v g="$mono_gain" 'BEGIN{print g+20}')
    else
      mono_gain=20
    fi
    mono_gain=$(awk -v g="$mono_gain" 'BEGIN{if(g<10)g=10; if(g>60)g=60; print g}')
  fi

  local total=$(( c_cnt + g_cnt + m_cnt )); (( total==0 )) && { echo "$base_low $base_high"; return; }
  local wC=$(awk -v n="$c_cnt" -v t="$total" 'BEGIN{print (t>0)?n/t:0}')
  local wG=$(awk -v n="$g_cnt" -v t="$total" 'BEGIN{print (t>0)?n/t:0}')
  local wM=$(awk -v n="$m_cnt" -v t="$total" 'BEGIN{print (t>0)?n/t:0}')
  local img_gain=$(awk -v c="$c_gain" -v g="$g_gain" -v m="$mono_gain" -v wC="$wC" -v wG="$wG" -v wM="$wM" \
                   'BEGIN{print c*wC + g*wG + m*wM}')

  local q_bonus=0
  if (( jpegq <= 68 )); then q_bonus=8
  elif (( jpegq <= 72 )); then q_bonus=4
  else q_bonus=2
  fi

  local mid=$(awk -v bL="$base_low" -v bH="$base_high" -v i="$img_gain" -v qb="$q_bonus" \
              'BEGIN{print ( (bL+bH)/2 + i + qb )}')
  mid=$(awk -v m="$mid" 'BEGIN{if(m<3)m=3; if(m>80)m=80; print m}')
  local low=$(awk -v m="$mid" 'BEGIN{print (m*0.7)}')
  local high=$(awk -v m="$mid" 'BEGIN{print (m*1.3>90?90:m*1.3)}')
  printf '%.1f %.1f\n' "$low" "$high"
}

SKIP_UNDER_RESOLVED=""; [[ -n "$SKIP_UNDER_BYTES" ]] && SKIP_UNDER_RESOLVED="$(parse_bytes "$SKIP_UNDER_BYTES")"

process_one() {
  emulate -L zsh
  unsetopt nounset

  local IN="${1-}" OUT_REQ="${2-}" PRE="${3-}" JQ="${4-}" INP="${5-}" \
        KEEP_META="${6-}" KEEP_DT="${7-}" MINGAIN="${8-}" DETER="${9-}" \
        PASS="${10-}" HOOK="${11-}" SC="${12-}"

  if [[ -z "$IN" ]]; then
    print -u2 "INTERNAL ERROR: process_one called without input path"
    return 2
  fi

  local orig="$IN"
  local base="${IN%.*}"
  if [[ -z "$OUT_REQ" ]]; then
    local default_out="${base}_deflyt.pdf"
    OUT="$(unique_filename "$default_out")"
  else
    OUT="$OUT_REQ"
  fi

  if $DEBUG; then 
    printf 'DEBUG: IN="%s" OUT="%s" PRESET=%s\n' "$IN" "$OUT" "$PRE"
  fi
  
  # Handle encryption
  local encrypted="no"
  if [[ -n "$PASS" ]]; then
    local dec="$(mktemp "${TMPDIR:-/tmp}/pdf-deflyt.dec.XXXXXXXX")"
    chmod 600 "$dec"  # Restrict permissions immediately
    if qpdf --password="$PASS" --decrypt "$IN" "$dec" >/dev/null 2>&1; then
      IN="$dec"
      trap "rm -f '$dec' 2>/dev/null || true" EXIT
    else
      rm -f "$dec" 2>/dev/null || true
      log "SKIP: $orig (incorrect password)"
      return 0
    fi
  else
    if pdfinfo "$IN" 2>/dev/null | command egrep -qi '^Encrypted:\s*yes'; then
      log "SKIP: $IN (encrypted - use --password or --password-file to process)"
      return 0
    fi
  fi

  local atime mtime
  if $KEEP_DT; then
    atime=$(stat_time "$orig" atime)
    mtime=$(stat_time "$orig" mtime)
  fi

  if [[ ! -r "$IN" ]]; then
    log "SKIP (unreadable): $IN"
    return 2
  fi

  local dir="$(dirname "$IN")"
  local tmp1="$(mktemp "${TMPDIR:-/tmp}/pdf-deflyt.opt.XXXXXXXX")"
  local tmp2="$(mktemp "${TMPDIR:-/tmp}/pdf-deflyt.gs.XXXXXXXX")"
  local tmp3="$(mktemp "${TMPDIR:-/tmp}/pdf-deflyt.fin.XXXXXXXX")"
  chmod 600 "$tmp1" "$tmp2" "$tmp3"

  setopt localtraps
  cleanup() { rm -f "$tmp1" "$tmp2" "$tmp3" 2>/dev/null || true; }
  trap 'cleanup' EXIT

  local ORIG_BYTES=$(size_of "$orig")

  # Structural optimization
  if ! pdfcpu optimize -quiet "$IN" "$tmp1" >/dev/null 2>&1; then
    if [[ -r "$IN" ]]; then
      cp "$IN" "$tmp1"
    else
      log "SKIP (optimize failed): $IN"
      return 2
    fi
  fi

  # Analyze images
  read -r C_CNT G_CNT M_CNT C_MED G_MED M_MED C_MIN G_MIN M_MIN <<<"$(analyse_pdf "$tmp1")"
  local NO_IMAGES=false; (( C_CNT + G_CNT + M_CNT == 0 )) && NO_IMAGES=true

  # Determine compression targets
  local C_RES=200 G_RES=200 M_RES=900 JPEGQ=74 PRE_EFF="$PRE" KEEP_META_EFF="$KEEP_METADATA" DET_EFF="$DETERMINISTIC"
  case "$PRE" in
    light)       C_RES=300; G_RES=300; M_RES=1200; JPEGQ=78 ;;
    extreme)     C_RES=144; G_RES=144; M_RES=600;  JPEGQ=68 ;;
    lossless)    C_RES=0;   G_RES=0;   M_RES=0 ;;
    archive)     C_RES=240; G_RES=240; M_RES=900; KEEP_META_EFF=false; DET_EFF=true; JPEGQ=74 ;;
    aggressive)  C_RES=0;   G_RES=0;   M_RES=0;   JPEGQ=75; KEEP_META_EFF=false; DET_EFF=true ;;
    standard)
      if (( C_CNT > 0 )); then
        local target=$(( ${C_MED%.*} >= 380 ? 220 : 200 ))
        C_RES=$(( target > 150 ? target : 150 ))
      fi
      if (( G_CNT > 0 )); then
        local target=$(( ${G_MED%.*} >= 380 ? 220 : 200 ))
        G_RES=$(( target > 150 ? target : 150 ))
      fi
      if (( M_CNT > 0 )); then M_RES=$(( ${M_MED%.*} >= 900 ? 900 : 600 )); fi
      if (( C_CNT + G_CNT > 0 )); then JPEGQ=$(( (${C_MED%.*}+${G_MED%.*} >= 700) ? 68 : 72 )); fi
      ;;
    *) echo "Unknown preset: $PRE" >&2; return 2 ;;
  esac
  [[ -n "$JQ" ]] && JPEGQ="$JQ"

  if $DEBUG; then
    read -r EST_LOW EST_HIGH <<<"$(estimate_savings "$PRE" "$NO_IMAGES" "$C_CNT" "$G_CNT" "$M_CNT" "$C_MED" "$G_MED" "$M_MED" "$C_RES" "$G_RES" "$M_RES" "$JPEGQ")"
    printf "  Images: C(cnt=%s med=%.0f min=%.0f) G(cnt=%s med=%.0f min=%.0f) M(cnt=%s med=%.0f min=%.0f)\n" \
      "$C_CNT" "$C_MED" "$C_MIN" "$G_CNT" "$G_MED" "$G_MIN" "$M_CNT" "$M_MED" "$M_MIN"
    printf "  Targets: C_RES=%s G_RES=%s M_RES=%s JPEGQ=%s\n" "$C_RES" "$G_RES" "$M_RES" "$JPEGQ"
    printf "  Est. savings: %s–%s%%\n" "$EST_LOW" "$EST_HIGH"
    pdfimages -list "$tmp1" 2>/dev/null | tail -n +3 | head -10
    return 0
  fi

  # Detect ICC profile images (more robust detection)
  # ICC images often have encoding that Ghostscript can corrupt, so we use ImageMagick instead
  local HAS_ICC=false
  local icc_check
  if icc_check="$(pdfimages -list "$tmp1" 2>/dev/null)"; then
    # Check if any image has ICC color profile (look for 'icc' in the color column)
    # Parse header to find color column, then check data rows
    if print -r -- "$icc_check" | awk '
      BEGIN { color_col=0; found=0 }
      /^page[[:space:]]+num[[:space:]]+type/ {
        for (i=1; i<=NF; i++) {
          if ($i == "color") { color_col=i; break }
        }
        next
      }
      /^-+/ { next }
      {
        if (color_col > 0 && NF >= color_col) {
          if (tolower($color_col) == "icc") {
            found=1
            exit
          }
        }
      }
      END { exit (found ? 0 : 1) }
    '; then
      HAS_ICC=true
    fi
  fi

  # Image compression
  if [[ "$PRE" == "lossless" || "$NO_IMAGES" == true ]]; then
    cp "$tmp1" "$tmp2"
  elif $HAS_ICC; then
    log "NOTICE: Detected ICC profile images, using ImageMagick-based compression"
    if ! python_recompress_images "$tmp1" "$tmp2" "$JPEGQ"; then
      log "WARNING: ImageMagick not found - using structural compression only (1-5% typical savings)"
      log "         Install ImageMagick for better compression: brew install imagemagick"
      cp "$tmp1" "$tmp2"
    fi
  elif [[ "$PRE" == "aggressive" ]]; then
    if ! gs_pass "$tmp1" "$tmp2" "$JPEGQ" "$DET_EFF" "$C_RES" "$G_RES" "$M_RES"; then
      log "WARNING: Ghostscript compression failed, using structural compression only"
    fi
    [[ ! -s "$tmp2" ]] && cp "$tmp1" "$tmp2"
  elif (( (C_CNT > 0 && ${C_MIN%.*} > 0 && ${C_MIN%.*} < C_RES) || \
          (G_CNT > 0 && ${G_MIN%.*} > 0 && ${G_MIN%.*} < G_RES) )); then
    log "NOTICE: Images below target resolution, using structural compression only"
    cp "$tmp1" "$tmp2"
  else
    if ! gs_pass "$tmp1" "$tmp2" "$JPEGQ" "$DET_EFF" "$C_RES" "$G_RES" "$M_RES"; then
      log "WARNING: Ghostscript compression failed, using structural compression only"
    fi
    [[ ! -s "$tmp2" ]] && cp "$tmp1" "$tmp2"
  fi

  # Final optimization
  if ! pdfcpu optimize -quiet "$tmp2" "$tmp3" >/dev/null 2>&1; then
    [[ -s "$tmp2" ]] && cp "$tmp2" "$tmp3" || cp "$tmp1" "$tmp3"
  fi
  if ! qpdf --linearize "$tmp3" "${tmp3}.w" >/dev/null 2>&1 || ! mv "${tmp3}.w" "$tmp3" 2>/dev/null; then
    $DEBUG && log "WARNING: QPDF linearization failed, continuing without linearization"
    rm -f "${tmp3}.w" 2>/dev/null || true
  fi
  if ! mutool clean -z "$tmp3" "${tmp3}.c" >/dev/null 2>&1 || ! mv "${tmp3}.c" "$tmp3" 2>/dev/null; then
    $DEBUG && log "WARNING: MuPDF clean failed, continuing without additional cleaning"
    rm -f "${tmp3}.c" 2>/dev/null || true
  fi
  if ! $KEEP_META_EFF; then
    if ! exiftool -overwrite_original -all= "$tmp3" >/dev/null 2>&1; then
      $DEBUG && log "WARNING: Metadata removal failed, continuing with metadata intact"
    fi
  fi

  local OUT_BYTES=$(size_of "$tmp3")
  local SAVEPCT=$(awk -v a="$OUT_BYTES" -v b="$ORIG_BYTES" 'BEGIN{printf "%.2f",(b>0)?(100*(1-a/b)):0}')
  local replace_ok=$(awk -v s="$SAVEPCT" -v m="$MINGAIN" -v a="$OUT_BYTES" -v b="$ORIG_BYTES" 'BEGIN{print (a<b && s>=m)?1:0}')
  local note="ok"
  
  if [[ "$replace_ok" -eq 1 ]]; then
    if $INPLACE; then
      mv "$tmp3" "$orig"
      $KEEP_DT && restore_times "$orig" "$orig"
      OUT="$orig"
    else
      mv "$tmp3" "$OUT"
      $KEEP_DT && restore_times "$orig" "$OUT"
    fi
  else
    note="kept-original"
    ! $INPLACE && cp "$orig" "$OUT"
  fi

  if $SIDECAR; then
    sha_sidecar pre "$orig" || log "WARNING: Failed to create pre-compression SHA256 sidecar"
    sha_sidecar post "$OUT" || log "WARNING: Failed to create post-compression SHA256 sidecar"
  fi

  if [[ -n "$POST_HOOK" ]]; then
    cmd=${POST_HOOK//\{\}/${(q)OUT}}
    if ! env IN="$orig" OUT="$OUT" ORIG_BYTES="$ORIG_BYTES" OUT_BYTES="$OUT_BYTES" \
             PRESET="$PRE" SAVEPCT="$SAVEPCT" /bin/zsh -lc -- "$cmd"; then
      log "WARNING: Post-hook command failed: $cmd"
    fi
  fi
  
  if [[ -n "$LOGFILE" ]]; then
    local ratio=$(awk -v a="$OUT_BYTES" -v b="$ORIG_BYTES" 'BEGIN{printf "%.4f",(b>0)?a/b:1}')
    printf '%s,%s,%s,%.4f,%s,%s\n' "$orig" "$ORIG_BYTES" "$OUT_BYTES" "$ratio" "$PRE" "$note" >> "$LOGFILE"
  fi
  
  $QUIET || printf '→ %s  (%.1f%% smaller)  [%s]\n' "$OUT" "$SAVEPCT" "$note"
  cleanup
}

run_wrapper() {
  emulate -L zsh
  local f="$1" out="${2-}"

  [[ -z "$f" ]] && { log "SKIP (empty path)"; return 0; }
  [[ ! -r "$f" ]] && { log "SKIP (unreadable): $f"; return 0; }

  if [[ -n "${SKIP_UNDER_RESOLVED:-}" ]]; then
    local sz=$(size_of "$f")
    [[ -n "$sz" && "$sz" -lt "$SKIP_UNDER_RESOLVED" ]] && { log "SKIP (too small): $f"; return 0; }
  fi

  if [[ "${DRYRUN:-false}" == true ]]; then
    local tmp1="$(mktemp -t pdfdeflyt.dry.XXXXXX)"
    local ORIG_BYTES=$(size_of "$f")

    pdfcpu optimize -quiet "$f" "$tmp1" >/dev/null 2>&1 || cp "$f" "$tmp1" || { echo "DRY: $f (unreadable)"; return 0; }

    read -r C_CNT G_CNT M_CNT C_MED G_MED M_MED C_MIN G_MIN M_MIN <<<"$(analyse_pdf "$tmp1")"
    local NO_IMAGES=false; (( C_CNT + G_CNT + M_CNT == 0 )) && NO_IMAGES=true

    local C_RES=200 G_RES=200 M_RES=900 JPEGQ=74
    case "$PRESET" in
      light)       C_RES=300; G_RES=300; M_RES=1200; JPEGQ=78 ;;
      extreme)     C_RES=144; G_RES=144; M_RES=600;  JPEGQ=68 ;;
      archive)     C_RES=240; G_RES=240; M_RES=900;  JPEGQ=74 ;;
      lossless)    C_RES=0;   G_RES=0;   M_RES=0;    JPEGQ=74 ;;
      aggressive)  C_RES=0;   G_RES=0;   M_RES=0;    JPEGQ=75 ;;
      standard)
        if (( C_CNT > 0 )); then
          local target=$(( ${C_MED%.*} >= 380 ? 220 : 200 ))
          C_RES=$(( target > 150 ? target : 150 ))
        fi
        if (( G_CNT > 0 )); then
          local target=$(( ${G_MED%.*} >= 380 ? 220 : 200 ))
          G_RES=$(( target > 150 ? target : 150 ))
        fi
        if (( M_CNT > 0 )); then M_RES=$(( ${M_MED%.*} >= 900 ? 900 : 600 )); fi
        JPEGQ=${JPEGQ_OVERRIDE:-74}
        ;;
    esac

    read -r EST_LOW EST_HIGH <<<"$(estimate_savings "$PRESET" "$NO_IMAGES" "$C_CNT" "$G_CNT" "$M_CNT" \
                                    "$C_MED" "$G_MED" "$M_MED" "$C_RES" "$G_RES" "$M_RES" "$JPEGQ")"

    local est_low_bytes=$(awk -v o="$ORIG_BYTES" -v p="$EST_HIGH" 'BEGIN{print (o*(100-p)/100)}')
    local est_high_bytes=$(awk -v o="$ORIG_BYTES" -v p="$EST_LOW"  'BEGIN{print (o*(100-p)/100)}')

    printf 'DRY: %s  preset=%s  est_savings≈%s–%s%%  est_size≈%s–%s (from %s)\n' \
        "$f" "$PRESET" "$EST_LOW" "$EST_HIGH" \
        "$(fmt_bytes "$est_low_bytes")" "$(fmt_bytes "$est_high_bytes")" \
        "$(fmt_bytes "$ORIG_BYTES")"

    rm -f "$tmp1" >/dev/null 2>&1 || true
    return 0
  fi

  process_one "$f" "$out" "$PRESET" "$JPEGQ_OVERRIDE" "$INPLACE" "$KEEP_METADATA" "$KEEP_DATE" \
              "$MIN_GAIN" "$DETERMINISTIC" "$PASSWORD" "$POST_HOOK" "$SIDECAR"
}

if $INTERNAL_ONE; then
  f="${FILES[1]}"; run_wrapper "$f" ""; exit 0
fi
if [[ -n "$OUT_SINGLE" ]]; then
  run_wrapper "${FILES[1]}" "$OUT_SINGLE"; exit 0
fi

if (( JOBS > 1 )) && $PARALLEL_OK; then
  # Progress indicator for parallel mode
  local total="${#FILES[@]}"
  $QUIET || (( total > 1 )) && log "Processing $total files in parallel (${JOBS} workers)..."

  env PRESET="$PRESET" JPEGQ_OVERRIDE="$JPEGQ_OVERRIDE" INPLACE="$INPLACE" \
      KEEP_METADATA="$KEEP_METADATA" KEEP_DATE="$KEEP_DATE" MIN_GAIN="$MIN_GAIN" \
      DETERMINISTIC="$DETERMINISTIC" PASSWORD="$PASSWORD" POST_HOOK="$POST_HOOK" \
      SIDECAR="$SIDECAR" DRYRUN="$DRYRUN" DEBUG="$DEBUG" \
      SKIP_UNDER_BYTES="$SKIP_UNDER_BYTES" SKIP_UNDER_RESOLVED="$SKIP_UNDER_RESOLVED" \
      LOGFILE="$LOGFILE" QUIET="$QUIET" \
  command parallel -j "$JOBS" --no-notice --will-cite -- \
    "$0" --internal-one {} ::: "${FILES[@]}"
else
  # Progress indicator for sequential mode
  local total="${#FILES[@]}"
  local current=0

  for f in "${FILES[@]}"; do
    ((current++))
    if ! $QUIET && (( total > 1 )); then
      local basename="${f##*/}"
      printf 'Processing (%d/%d): %s\n' "$current" "$total" "$basename" >&2
    fi
    run_wrapper "$f" ""
  done
fi